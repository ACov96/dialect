Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    END
    EXIT

Grammar

Rule 0     S' -> statement_list
Rule 1     statement_list -> statement statement_list
Rule 2     statement_list -> empty
Rule 3     empty -> <empty>
Rule 4     statement -> IMPORT STRING SEMICOLON
Rule 5     statement -> assignment SEMICOLON
Rule 6     statement -> conditional
Rule 7     statement -> expr SEMICOLON
Rule 8     statement -> macro_def
Rule 9     statement -> macro_call
Rule 10    assignment -> l_value EQUAL r_value
Rule 11    statement -> loop
Rule 12    loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
Rule 13    statement -> fun_def
Rule 14    fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
Rule 15    statement -> RETURN expr SEMICOLON
Rule 16    id_list -> ID
Rule 17    id_list -> ID COMMA id_list
Rule 18    id_list -> empty
Rule 19    conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
Rule 20    conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif
Rule 21    conditional_elif -> empty
Rule 22    conditional_else -> ELSE LBRACE statement_list RBRACE
Rule 23    conditional_else -> empty
Rule 24    r_value -> expr
Rule 25    l_value -> ID
Rule 26    l_value -> ID fields
Rule 27    l_value -> PLACEHOLDER
Rule 28    l_value -> PLACEHOLDER fields
Rule 29    fields -> LBRACKET expr RBRACKET
Rule 30    fields -> LBRACKET expr RBRACKET fields
Rule 31    expr -> alg_op
Rule 32    expr -> STRING
Rule 33    expr -> NUMBER
Rule 34    expr -> BOOL
Rule 35    expr -> NULL
Rule 36    expr -> func_call
Rule 37    expr -> ID
Rule 38    expr -> LPAREN expr RPAREN
Rule 39    expr -> anonymous_fun
Rule 40    func_call -> ID LPAREN arg_list RPAREN
Rule 41    arg_list -> empty
Rule 42    arg_list -> expr
Rule 43    arg_list -> expr COMMA arg_list
Rule 44    alg_op -> expr PLUS expr
Rule 45    alg_op -> expr MINUS expr
Rule 46    alg_op -> expr MULTIPLY expr
Rule 47    alg_op -> expr DIVIDE expr
Rule 48    expr -> LBRACKET arg_list RBRACKET
Rule 49    expr -> LBRACE record_list RBRACE
Rule 50    expr -> LPAREN statement_list RPAREN
Rule 51    record_list -> ID COLON expr
Rule 52    record_list -> ID COLON expr COMMA record_list
Rule 53    record_list -> empty
Rule 54    expr -> expr LBRACKET expr RBRACKET
Rule 55    expr -> comp_op
Rule 56    expr -> PLACEHOLDER
Rule 57    comp_op -> expr EQUAL EQUAL expr
Rule 58    comp_op -> expr BANG EQUAL expr
Rule 59    comp_op -> expr GT expr
Rule 60    comp_op -> expr GT EQUAL expr
Rule 61    comp_op -> expr LT expr
Rule 62    comp_op -> expr LT EQUAL expr
Rule 63    expr -> log_op
Rule 64    log_op -> expr AND expr
Rule 65    log_op -> expr OR expr
Rule 66    log_op -> NOT expr
Rule 67    macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE
Rule 68    macro_def_arg_list -> ATOM macro_def_arg_list_rec
Rule 69    macro_def_arg_list_rec -> PLACEHOLDER macro_def_arg_list_rec
Rule 70    macro_def_arg_list_rec -> ATOM macro_def_arg_list_rec
Rule 71    macro_def_arg_list_rec -> empty
Rule 72    macro_call -> ATOM macro_arg_list SEMICOLON
Rule 73    macro_arg_list -> ATOM macro_arg_list
Rule 74    macro_arg_list -> expr macro_arg_list
Rule 75    macro_arg_list -> empty
Rule 76    anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE

Terminals, with rules where they appear

AND                  : 64
ATOM                 : 68 70 72 73
BANG                 : 58
BOOL                 : 34
COLON                : 51 52
COMMA                : 17 43 52
DIVIDE               : 47
ELIF                 : 20
ELSE                 : 22
END                  : 
EQUAL                : 10 57 57 58 60 62
EXIT                 : 
FUN                  : 14
GT                   : 59 60
ID                   : 14 16 17 25 26 37 40 51 52
IF                   : 19
IMPORT               : 4
LBRACE               : 12 14 19 20 22 49 67 76
LBRACKET             : 29 30 48 54
LPAREN               : 12 14 19 20 38 40 50 76
LT                   : 61 62
MAC                  : 67
MINUS                : 45
MULTIPLY             : 46
NOT                  : 66
NULL                 : 35
NUMBER               : 33
OR                   : 65
PLACEHOLDER          : 27 28 56 69
PLUS                 : 44
RBRACE               : 12 14 19 20 22 49 67 76
RBRACKET             : 29 30 48 54
RETURN               : 15
RPAREN               : 12 14 19 20 38 40 50 76
SEMICOLON            : 4 5 7 15 72
STRING               : 4 32
WHILE                : 12
error                : 

Nonterminals, with rules where they appear

alg_op               : 31
anonymous_fun        : 39
arg_list             : 40 43 48
assignment           : 5
comp_op              : 55
conditional          : 6
conditional_elif     : 19 20
conditional_else     : 19
empty                : 2 18 21 23 41 53 71 75
expr                 : 7 12 15 19 20 24 29 30 38 42 43 44 44 45 45 46 46 47 47 51 52 54 54 57 57 58 58 59 59 60 60 61 61 62 62 64 64 65 65 66 74
fields               : 26 28 30
fun_def              : 13
func_call            : 36
id_list              : 14 17 76
l_value              : 10
log_op               : 63
loop                 : 11
macro_arg_list       : 72 73 74
macro_call           : 9
macro_def            : 8
macro_def_arg_list   : 67
macro_def_arg_list_rec : 68 69 70
r_value              : 10
record_list          : 49 52
statement            : 1
statement_list       : 1 12 14 19 20 22 50 67 76 0

Parsing method: LALR

state 0

    (0) S' -> . statement_list
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    $end            reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    statement_list                 shift and go to state 1
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 1

    (0) S' -> statement_list .



state 2

    (1) statement_list -> statement . statement_list
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    statement                      shift and go to state 2
    statement_list                 shift and go to state 34
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 3

    (2) statement_list -> empty .

    $end            reduce using rule 2 (statement_list -> empty .)
    RPAREN          reduce using rule 2 (statement_list -> empty .)
    RBRACE          reduce using rule 2 (statement_list -> empty .)


state 4

    (4) statement -> IMPORT . STRING SEMICOLON

    STRING          shift and go to state 35


state 5

    (32) expr -> STRING .

    SEMICOLON       reduce using rule 32 (expr -> STRING .)
    LBRACKET        reduce using rule 32 (expr -> STRING .)
    PLUS            reduce using rule 32 (expr -> STRING .)
    MINUS           reduce using rule 32 (expr -> STRING .)
    MULTIPLY        reduce using rule 32 (expr -> STRING .)
    DIVIDE          reduce using rule 32 (expr -> STRING .)
    EQUAL           reduce using rule 32 (expr -> STRING .)
    BANG            reduce using rule 32 (expr -> STRING .)
    GT              reduce using rule 32 (expr -> STRING .)
    LT              reduce using rule 32 (expr -> STRING .)
    AND             reduce using rule 32 (expr -> STRING .)
    OR              reduce using rule 32 (expr -> STRING .)
    RPAREN          reduce using rule 32 (expr -> STRING .)
    COMMA           reduce using rule 32 (expr -> STRING .)
    RBRACKET        reduce using rule 32 (expr -> STRING .)
    ATOM            reduce using rule 32 (expr -> STRING .)
    STRING          reduce using rule 32 (expr -> STRING .)
    NUMBER          reduce using rule 32 (expr -> STRING .)
    BOOL            reduce using rule 32 (expr -> STRING .)
    NULL            reduce using rule 32 (expr -> STRING .)
    ID              reduce using rule 32 (expr -> STRING .)
    LPAREN          reduce using rule 32 (expr -> STRING .)
    LBRACE          reduce using rule 32 (expr -> STRING .)
    PLACEHOLDER     reduce using rule 32 (expr -> STRING .)
    NOT             reduce using rule 32 (expr -> STRING .)
    RBRACE          reduce using rule 32 (expr -> STRING .)


state 6

    (5) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 36


state 7

    (6) statement -> conditional .

    IMPORT          reduce using rule 6 (statement -> conditional .)
    RETURN          reduce using rule 6 (statement -> conditional .)
    IF              reduce using rule 6 (statement -> conditional .)
    STRING          reduce using rule 6 (statement -> conditional .)
    NUMBER          reduce using rule 6 (statement -> conditional .)
    BOOL            reduce using rule 6 (statement -> conditional .)
    NULL            reduce using rule 6 (statement -> conditional .)
    ID              reduce using rule 6 (statement -> conditional .)
    LPAREN          reduce using rule 6 (statement -> conditional .)
    LBRACKET        reduce using rule 6 (statement -> conditional .)
    LBRACE          reduce using rule 6 (statement -> conditional .)
    PLACEHOLDER     reduce using rule 6 (statement -> conditional .)
    MAC             reduce using rule 6 (statement -> conditional .)
    ATOM            reduce using rule 6 (statement -> conditional .)
    WHILE           reduce using rule 6 (statement -> conditional .)
    FUN             reduce using rule 6 (statement -> conditional .)
    NOT             reduce using rule 6 (statement -> conditional .)
    $end            reduce using rule 6 (statement -> conditional .)
    RPAREN          reduce using rule 6 (statement -> conditional .)
    RBRACE          reduce using rule 6 (statement -> conditional .)


state 8

    (7) statement -> expr . SEMICOLON
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       shift and go to state 37
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 9

    (8) statement -> macro_def .

    IMPORT          reduce using rule 8 (statement -> macro_def .)
    RETURN          reduce using rule 8 (statement -> macro_def .)
    IF              reduce using rule 8 (statement -> macro_def .)
    STRING          reduce using rule 8 (statement -> macro_def .)
    NUMBER          reduce using rule 8 (statement -> macro_def .)
    BOOL            reduce using rule 8 (statement -> macro_def .)
    NULL            reduce using rule 8 (statement -> macro_def .)
    ID              reduce using rule 8 (statement -> macro_def .)
    LPAREN          reduce using rule 8 (statement -> macro_def .)
    LBRACKET        reduce using rule 8 (statement -> macro_def .)
    LBRACE          reduce using rule 8 (statement -> macro_def .)
    PLACEHOLDER     reduce using rule 8 (statement -> macro_def .)
    MAC             reduce using rule 8 (statement -> macro_def .)
    ATOM            reduce using rule 8 (statement -> macro_def .)
    WHILE           reduce using rule 8 (statement -> macro_def .)
    FUN             reduce using rule 8 (statement -> macro_def .)
    NOT             reduce using rule 8 (statement -> macro_def .)
    $end            reduce using rule 8 (statement -> macro_def .)
    RPAREN          reduce using rule 8 (statement -> macro_def .)
    RBRACE          reduce using rule 8 (statement -> macro_def .)


state 10

    (9) statement -> macro_call .

    IMPORT          reduce using rule 9 (statement -> macro_call .)
    RETURN          reduce using rule 9 (statement -> macro_call .)
    IF              reduce using rule 9 (statement -> macro_call .)
    STRING          reduce using rule 9 (statement -> macro_call .)
    NUMBER          reduce using rule 9 (statement -> macro_call .)
    BOOL            reduce using rule 9 (statement -> macro_call .)
    NULL            reduce using rule 9 (statement -> macro_call .)
    ID              reduce using rule 9 (statement -> macro_call .)
    LPAREN          reduce using rule 9 (statement -> macro_call .)
    LBRACKET        reduce using rule 9 (statement -> macro_call .)
    LBRACE          reduce using rule 9 (statement -> macro_call .)
    PLACEHOLDER     reduce using rule 9 (statement -> macro_call .)
    MAC             reduce using rule 9 (statement -> macro_call .)
    ATOM            reduce using rule 9 (statement -> macro_call .)
    WHILE           reduce using rule 9 (statement -> macro_call .)
    FUN             reduce using rule 9 (statement -> macro_call .)
    NOT             reduce using rule 9 (statement -> macro_call .)
    $end            reduce using rule 9 (statement -> macro_call .)
    RPAREN          reduce using rule 9 (statement -> macro_call .)
    RBRACE          reduce using rule 9 (statement -> macro_call .)


state 11

    (11) statement -> loop .

    IMPORT          reduce using rule 11 (statement -> loop .)
    RETURN          reduce using rule 11 (statement -> loop .)
    IF              reduce using rule 11 (statement -> loop .)
    STRING          reduce using rule 11 (statement -> loop .)
    NUMBER          reduce using rule 11 (statement -> loop .)
    BOOL            reduce using rule 11 (statement -> loop .)
    NULL            reduce using rule 11 (statement -> loop .)
    ID              reduce using rule 11 (statement -> loop .)
    LPAREN          reduce using rule 11 (statement -> loop .)
    LBRACKET        reduce using rule 11 (statement -> loop .)
    LBRACE          reduce using rule 11 (statement -> loop .)
    PLACEHOLDER     reduce using rule 11 (statement -> loop .)
    MAC             reduce using rule 11 (statement -> loop .)
    ATOM            reduce using rule 11 (statement -> loop .)
    WHILE           reduce using rule 11 (statement -> loop .)
    FUN             reduce using rule 11 (statement -> loop .)
    NOT             reduce using rule 11 (statement -> loop .)
    $end            reduce using rule 11 (statement -> loop .)
    RPAREN          reduce using rule 11 (statement -> loop .)
    RBRACE          reduce using rule 11 (statement -> loop .)


state 12

    (13) statement -> fun_def .

    IMPORT          reduce using rule 13 (statement -> fun_def .)
    RETURN          reduce using rule 13 (statement -> fun_def .)
    IF              reduce using rule 13 (statement -> fun_def .)
    STRING          reduce using rule 13 (statement -> fun_def .)
    NUMBER          reduce using rule 13 (statement -> fun_def .)
    BOOL            reduce using rule 13 (statement -> fun_def .)
    NULL            reduce using rule 13 (statement -> fun_def .)
    ID              reduce using rule 13 (statement -> fun_def .)
    LPAREN          reduce using rule 13 (statement -> fun_def .)
    LBRACKET        reduce using rule 13 (statement -> fun_def .)
    LBRACE          reduce using rule 13 (statement -> fun_def .)
    PLACEHOLDER     reduce using rule 13 (statement -> fun_def .)
    MAC             reduce using rule 13 (statement -> fun_def .)
    ATOM            reduce using rule 13 (statement -> fun_def .)
    WHILE           reduce using rule 13 (statement -> fun_def .)
    FUN             reduce using rule 13 (statement -> fun_def .)
    NOT             reduce using rule 13 (statement -> fun_def .)
    $end            reduce using rule 13 (statement -> fun_def .)
    RPAREN          reduce using rule 13 (statement -> fun_def .)
    RBRACE          reduce using rule 13 (statement -> fun_def .)


state 13

    (15) statement -> RETURN . expr SEMICOLON
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 49
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 14

    (10) assignment -> l_value . EQUAL r_value

    EQUAL           shift and go to state 52


state 15

    (19) conditional -> IF . LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else

    LPAREN          shift and go to state 53


state 16

    (38) expr -> LPAREN . expr RPAREN
    (50) expr -> LPAREN . statement_list RPAREN
    (76) anonymous_fun -> LPAREN . id_list RPAREN LBRACE statement_list RBRACE
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (16) id_list -> . ID
    (17) id_list -> . ID COMMA id_list
    (18) id_list -> . empty
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 57
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    NOT             shift and go to state 33
    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RPAREN          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32

    expr                           shift and go to state 54
    statement_list                 shift and go to state 55
    id_list                        shift and go to state 56
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28
    statement                      shift and go to state 2
    empty                          shift and go to state 58
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14

state 17

    (49) expr -> LBRACE . record_list RBRACE
    (51) record_list -> . ID COLON expr
    (52) record_list -> . ID COLON expr COMMA record_list
    (53) record_list -> . empty
    (3) empty -> .

    ID              shift and go to state 60
    RBRACE          reduce using rule 3 (empty -> .)

    record_list                    shift and go to state 59
    empty                          shift and go to state 61

state 18

    (31) expr -> alg_op .

    SEMICOLON       reduce using rule 31 (expr -> alg_op .)
    LBRACKET        reduce using rule 31 (expr -> alg_op .)
    PLUS            reduce using rule 31 (expr -> alg_op .)
    MINUS           reduce using rule 31 (expr -> alg_op .)
    MULTIPLY        reduce using rule 31 (expr -> alg_op .)
    DIVIDE          reduce using rule 31 (expr -> alg_op .)
    EQUAL           reduce using rule 31 (expr -> alg_op .)
    BANG            reduce using rule 31 (expr -> alg_op .)
    GT              reduce using rule 31 (expr -> alg_op .)
    LT              reduce using rule 31 (expr -> alg_op .)
    AND             reduce using rule 31 (expr -> alg_op .)
    OR              reduce using rule 31 (expr -> alg_op .)
    RPAREN          reduce using rule 31 (expr -> alg_op .)
    COMMA           reduce using rule 31 (expr -> alg_op .)
    RBRACKET        reduce using rule 31 (expr -> alg_op .)
    ATOM            reduce using rule 31 (expr -> alg_op .)
    STRING          reduce using rule 31 (expr -> alg_op .)
    NUMBER          reduce using rule 31 (expr -> alg_op .)
    BOOL            reduce using rule 31 (expr -> alg_op .)
    NULL            reduce using rule 31 (expr -> alg_op .)
    ID              reduce using rule 31 (expr -> alg_op .)
    LPAREN          reduce using rule 31 (expr -> alg_op .)
    LBRACE          reduce using rule 31 (expr -> alg_op .)
    PLACEHOLDER     reduce using rule 31 (expr -> alg_op .)
    NOT             reduce using rule 31 (expr -> alg_op .)
    RBRACE          reduce using rule 31 (expr -> alg_op .)


state 19

    (33) expr -> NUMBER .

    SEMICOLON       reduce using rule 33 (expr -> NUMBER .)
    LBRACKET        reduce using rule 33 (expr -> NUMBER .)
    PLUS            reduce using rule 33 (expr -> NUMBER .)
    MINUS           reduce using rule 33 (expr -> NUMBER .)
    MULTIPLY        reduce using rule 33 (expr -> NUMBER .)
    DIVIDE          reduce using rule 33 (expr -> NUMBER .)
    EQUAL           reduce using rule 33 (expr -> NUMBER .)
    BANG            reduce using rule 33 (expr -> NUMBER .)
    GT              reduce using rule 33 (expr -> NUMBER .)
    LT              reduce using rule 33 (expr -> NUMBER .)
    AND             reduce using rule 33 (expr -> NUMBER .)
    OR              reduce using rule 33 (expr -> NUMBER .)
    RPAREN          reduce using rule 33 (expr -> NUMBER .)
    COMMA           reduce using rule 33 (expr -> NUMBER .)
    RBRACKET        reduce using rule 33 (expr -> NUMBER .)
    ATOM            reduce using rule 33 (expr -> NUMBER .)
    STRING          reduce using rule 33 (expr -> NUMBER .)
    NUMBER          reduce using rule 33 (expr -> NUMBER .)
    BOOL            reduce using rule 33 (expr -> NUMBER .)
    NULL            reduce using rule 33 (expr -> NUMBER .)
    ID              reduce using rule 33 (expr -> NUMBER .)
    LPAREN          reduce using rule 33 (expr -> NUMBER .)
    LBRACE          reduce using rule 33 (expr -> NUMBER .)
    PLACEHOLDER     reduce using rule 33 (expr -> NUMBER .)
    NOT             reduce using rule 33 (expr -> NUMBER .)
    RBRACE          reduce using rule 33 (expr -> NUMBER .)


state 20

    (34) expr -> BOOL .

    SEMICOLON       reduce using rule 34 (expr -> BOOL .)
    LBRACKET        reduce using rule 34 (expr -> BOOL .)
    PLUS            reduce using rule 34 (expr -> BOOL .)
    MINUS           reduce using rule 34 (expr -> BOOL .)
    MULTIPLY        reduce using rule 34 (expr -> BOOL .)
    DIVIDE          reduce using rule 34 (expr -> BOOL .)
    EQUAL           reduce using rule 34 (expr -> BOOL .)
    BANG            reduce using rule 34 (expr -> BOOL .)
    GT              reduce using rule 34 (expr -> BOOL .)
    LT              reduce using rule 34 (expr -> BOOL .)
    AND             reduce using rule 34 (expr -> BOOL .)
    OR              reduce using rule 34 (expr -> BOOL .)
    RPAREN          reduce using rule 34 (expr -> BOOL .)
    COMMA           reduce using rule 34 (expr -> BOOL .)
    RBRACKET        reduce using rule 34 (expr -> BOOL .)
    ATOM            reduce using rule 34 (expr -> BOOL .)
    STRING          reduce using rule 34 (expr -> BOOL .)
    NUMBER          reduce using rule 34 (expr -> BOOL .)
    BOOL            reduce using rule 34 (expr -> BOOL .)
    NULL            reduce using rule 34 (expr -> BOOL .)
    ID              reduce using rule 34 (expr -> BOOL .)
    LPAREN          reduce using rule 34 (expr -> BOOL .)
    LBRACE          reduce using rule 34 (expr -> BOOL .)
    PLACEHOLDER     reduce using rule 34 (expr -> BOOL .)
    NOT             reduce using rule 34 (expr -> BOOL .)
    RBRACE          reduce using rule 34 (expr -> BOOL .)


state 21

    (35) expr -> NULL .

    SEMICOLON       reduce using rule 35 (expr -> NULL .)
    LBRACKET        reduce using rule 35 (expr -> NULL .)
    PLUS            reduce using rule 35 (expr -> NULL .)
    MINUS           reduce using rule 35 (expr -> NULL .)
    MULTIPLY        reduce using rule 35 (expr -> NULL .)
    DIVIDE          reduce using rule 35 (expr -> NULL .)
    EQUAL           reduce using rule 35 (expr -> NULL .)
    BANG            reduce using rule 35 (expr -> NULL .)
    GT              reduce using rule 35 (expr -> NULL .)
    LT              reduce using rule 35 (expr -> NULL .)
    AND             reduce using rule 35 (expr -> NULL .)
    OR              reduce using rule 35 (expr -> NULL .)
    RPAREN          reduce using rule 35 (expr -> NULL .)
    COMMA           reduce using rule 35 (expr -> NULL .)
    RBRACKET        reduce using rule 35 (expr -> NULL .)
    ATOM            reduce using rule 35 (expr -> NULL .)
    STRING          reduce using rule 35 (expr -> NULL .)
    NUMBER          reduce using rule 35 (expr -> NULL .)
    BOOL            reduce using rule 35 (expr -> NULL .)
    NULL            reduce using rule 35 (expr -> NULL .)
    ID              reduce using rule 35 (expr -> NULL .)
    LPAREN          reduce using rule 35 (expr -> NULL .)
    LBRACE          reduce using rule 35 (expr -> NULL .)
    PLACEHOLDER     reduce using rule 35 (expr -> NULL .)
    NOT             reduce using rule 35 (expr -> NULL .)
    RBRACE          reduce using rule 35 (expr -> NULL .)


state 22

    (36) expr -> func_call .

    SEMICOLON       reduce using rule 36 (expr -> func_call .)
    LBRACKET        reduce using rule 36 (expr -> func_call .)
    PLUS            reduce using rule 36 (expr -> func_call .)
    MINUS           reduce using rule 36 (expr -> func_call .)
    MULTIPLY        reduce using rule 36 (expr -> func_call .)
    DIVIDE          reduce using rule 36 (expr -> func_call .)
    EQUAL           reduce using rule 36 (expr -> func_call .)
    BANG            reduce using rule 36 (expr -> func_call .)
    GT              reduce using rule 36 (expr -> func_call .)
    LT              reduce using rule 36 (expr -> func_call .)
    AND             reduce using rule 36 (expr -> func_call .)
    OR              reduce using rule 36 (expr -> func_call .)
    RPAREN          reduce using rule 36 (expr -> func_call .)
    COMMA           reduce using rule 36 (expr -> func_call .)
    RBRACKET        reduce using rule 36 (expr -> func_call .)
    ATOM            reduce using rule 36 (expr -> func_call .)
    STRING          reduce using rule 36 (expr -> func_call .)
    NUMBER          reduce using rule 36 (expr -> func_call .)
    BOOL            reduce using rule 36 (expr -> func_call .)
    NULL            reduce using rule 36 (expr -> func_call .)
    ID              reduce using rule 36 (expr -> func_call .)
    LPAREN          reduce using rule 36 (expr -> func_call .)
    LBRACE          reduce using rule 36 (expr -> func_call .)
    PLACEHOLDER     reduce using rule 36 (expr -> func_call .)
    NOT             reduce using rule 36 (expr -> func_call .)
    RBRACE          reduce using rule 36 (expr -> func_call .)


state 23

    (37) expr -> ID .
    (25) l_value -> ID .
    (26) l_value -> ID . fields
    (40) func_call -> ID . LPAREN arg_list RPAREN
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

  ! reduce/reduce conflict for EQUAL resolved using rule 25 (l_value -> ID .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMICOLON       reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    MULTIPLY        reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    BANG            reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    AND             reduce using rule 37 (expr -> ID .)
    OR              reduce using rule 37 (expr -> ID .)
    EQUAL           reduce using rule 25 (l_value -> ID .)
    LPAREN          shift and go to state 63
    LBRACKET        shift and go to state 64

  ! LBRACKET        [ reduce using rule 37 (expr -> ID .) ]
  ! EQUAL           [ reduce using rule 37 (expr -> ID .) ]

    fields                         shift and go to state 62

state 24

    (39) expr -> anonymous_fun .

    SEMICOLON       reduce using rule 39 (expr -> anonymous_fun .)
    LBRACKET        reduce using rule 39 (expr -> anonymous_fun .)
    PLUS            reduce using rule 39 (expr -> anonymous_fun .)
    MINUS           reduce using rule 39 (expr -> anonymous_fun .)
    MULTIPLY        reduce using rule 39 (expr -> anonymous_fun .)
    DIVIDE          reduce using rule 39 (expr -> anonymous_fun .)
    EQUAL           reduce using rule 39 (expr -> anonymous_fun .)
    BANG            reduce using rule 39 (expr -> anonymous_fun .)
    GT              reduce using rule 39 (expr -> anonymous_fun .)
    LT              reduce using rule 39 (expr -> anonymous_fun .)
    AND             reduce using rule 39 (expr -> anonymous_fun .)
    OR              reduce using rule 39 (expr -> anonymous_fun .)
    RPAREN          reduce using rule 39 (expr -> anonymous_fun .)
    COMMA           reduce using rule 39 (expr -> anonymous_fun .)
    RBRACKET        reduce using rule 39 (expr -> anonymous_fun .)
    ATOM            reduce using rule 39 (expr -> anonymous_fun .)
    STRING          reduce using rule 39 (expr -> anonymous_fun .)
    NUMBER          reduce using rule 39 (expr -> anonymous_fun .)
    BOOL            reduce using rule 39 (expr -> anonymous_fun .)
    NULL            reduce using rule 39 (expr -> anonymous_fun .)
    ID              reduce using rule 39 (expr -> anonymous_fun .)
    LPAREN          reduce using rule 39 (expr -> anonymous_fun .)
    LBRACE          reduce using rule 39 (expr -> anonymous_fun .)
    PLACEHOLDER     reduce using rule 39 (expr -> anonymous_fun .)
    NOT             reduce using rule 39 (expr -> anonymous_fun .)
    RBRACE          reduce using rule 39 (expr -> anonymous_fun .)


state 25

    (48) expr -> LBRACKET . arg_list RBRACKET
    (41) arg_list -> . empty
    (42) arg_list -> . expr
    (43) arg_list -> . expr COMMA arg_list
    (3) empty -> .
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    RBRACKET        reduce using rule 3 (empty -> .)
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    arg_list                       shift and go to state 65
    empty                          shift and go to state 66
    expr                           shift and go to state 67
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 26

    (55) expr -> comp_op .

    SEMICOLON       reduce using rule 55 (expr -> comp_op .)
    LBRACKET        reduce using rule 55 (expr -> comp_op .)
    PLUS            reduce using rule 55 (expr -> comp_op .)
    MINUS           reduce using rule 55 (expr -> comp_op .)
    MULTIPLY        reduce using rule 55 (expr -> comp_op .)
    DIVIDE          reduce using rule 55 (expr -> comp_op .)
    EQUAL           reduce using rule 55 (expr -> comp_op .)
    BANG            reduce using rule 55 (expr -> comp_op .)
    GT              reduce using rule 55 (expr -> comp_op .)
    LT              reduce using rule 55 (expr -> comp_op .)
    AND             reduce using rule 55 (expr -> comp_op .)
    OR              reduce using rule 55 (expr -> comp_op .)
    RPAREN          reduce using rule 55 (expr -> comp_op .)
    COMMA           reduce using rule 55 (expr -> comp_op .)
    RBRACKET        reduce using rule 55 (expr -> comp_op .)
    ATOM            reduce using rule 55 (expr -> comp_op .)
    STRING          reduce using rule 55 (expr -> comp_op .)
    NUMBER          reduce using rule 55 (expr -> comp_op .)
    BOOL            reduce using rule 55 (expr -> comp_op .)
    NULL            reduce using rule 55 (expr -> comp_op .)
    ID              reduce using rule 55 (expr -> comp_op .)
    LPAREN          reduce using rule 55 (expr -> comp_op .)
    LBRACE          reduce using rule 55 (expr -> comp_op .)
    PLACEHOLDER     reduce using rule 55 (expr -> comp_op .)
    NOT             reduce using rule 55 (expr -> comp_op .)
    RBRACE          reduce using rule 55 (expr -> comp_op .)


state 27

    (56) expr -> PLACEHOLDER .
    (27) l_value -> PLACEHOLDER .
    (28) l_value -> PLACEHOLDER . fields
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

  ! reduce/reduce conflict for EQUAL resolved using rule 27 (l_value -> PLACEHOLDER .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMICOLON       reduce using rule 56 (expr -> PLACEHOLDER .)
    PLUS            reduce using rule 56 (expr -> PLACEHOLDER .)
    MINUS           reduce using rule 56 (expr -> PLACEHOLDER .)
    MULTIPLY        reduce using rule 56 (expr -> PLACEHOLDER .)
    DIVIDE          reduce using rule 56 (expr -> PLACEHOLDER .)
    BANG            reduce using rule 56 (expr -> PLACEHOLDER .)
    GT              reduce using rule 56 (expr -> PLACEHOLDER .)
    LT              reduce using rule 56 (expr -> PLACEHOLDER .)
    AND             reduce using rule 56 (expr -> PLACEHOLDER .)
    OR              reduce using rule 56 (expr -> PLACEHOLDER .)
    RPAREN          reduce using rule 56 (expr -> PLACEHOLDER .)
    EQUAL           reduce using rule 27 (l_value -> PLACEHOLDER .)
    LBRACKET        shift and go to state 64

  ! LBRACKET        [ reduce using rule 56 (expr -> PLACEHOLDER .) ]
  ! EQUAL           [ reduce using rule 56 (expr -> PLACEHOLDER .) ]

    fields                         shift and go to state 68

state 28

    (63) expr -> log_op .

    SEMICOLON       reduce using rule 63 (expr -> log_op .)
    LBRACKET        reduce using rule 63 (expr -> log_op .)
    PLUS            reduce using rule 63 (expr -> log_op .)
    MINUS           reduce using rule 63 (expr -> log_op .)
    MULTIPLY        reduce using rule 63 (expr -> log_op .)
    DIVIDE          reduce using rule 63 (expr -> log_op .)
    EQUAL           reduce using rule 63 (expr -> log_op .)
    BANG            reduce using rule 63 (expr -> log_op .)
    GT              reduce using rule 63 (expr -> log_op .)
    LT              reduce using rule 63 (expr -> log_op .)
    AND             reduce using rule 63 (expr -> log_op .)
    OR              reduce using rule 63 (expr -> log_op .)
    RPAREN          reduce using rule 63 (expr -> log_op .)
    COMMA           reduce using rule 63 (expr -> log_op .)
    RBRACKET        reduce using rule 63 (expr -> log_op .)
    ATOM            reduce using rule 63 (expr -> log_op .)
    STRING          reduce using rule 63 (expr -> log_op .)
    NUMBER          reduce using rule 63 (expr -> log_op .)
    BOOL            reduce using rule 63 (expr -> log_op .)
    NULL            reduce using rule 63 (expr -> log_op .)
    ID              reduce using rule 63 (expr -> log_op .)
    LPAREN          reduce using rule 63 (expr -> log_op .)
    LBRACE          reduce using rule 63 (expr -> log_op .)
    PLACEHOLDER     reduce using rule 63 (expr -> log_op .)
    NOT             reduce using rule 63 (expr -> log_op .)
    RBRACE          reduce using rule 63 (expr -> log_op .)


state 29

    (67) macro_def -> MAC . macro_def_arg_list LBRACE statement_list RBRACE
    (68) macro_def_arg_list -> . ATOM macro_def_arg_list_rec

    ATOM            shift and go to state 70

    macro_def_arg_list             shift and go to state 69

state 30

    (72) macro_call -> ATOM . macro_arg_list SEMICOLON
    (73) macro_arg_list -> . ATOM macro_arg_list
    (74) macro_arg_list -> . expr macro_arg_list
    (75) macro_arg_list -> . empty
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (3) empty -> .
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    ATOM            shift and go to state 71
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    SEMICOLON       reduce using rule 3 (empty -> .)
    NOT             shift and go to state 33

    macro_arg_list                 shift and go to state 72
    expr                           shift and go to state 73
    empty                          shift and go to state 74
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 31

    (12) loop -> WHILE . LPAREN expr RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 75


state 32

    (14) fun_def -> FUN . ID LPAREN id_list RPAREN LBRACE statement_list RBRACE

    ID              shift and go to state 76


state 33

    (66) log_op -> NOT . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 77
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 34

    (1) statement_list -> statement statement_list .

    $end            reduce using rule 1 (statement_list -> statement statement_list .)
    RPAREN          reduce using rule 1 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 1 (statement_list -> statement statement_list .)


state 35

    (4) statement -> IMPORT STRING . SEMICOLON

    SEMICOLON       shift and go to state 78


state 36

    (5) statement -> assignment SEMICOLON .

    IMPORT          reduce using rule 5 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 5 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 5 (statement -> assignment SEMICOLON .)
    STRING          reduce using rule 5 (statement -> assignment SEMICOLON .)
    NUMBER          reduce using rule 5 (statement -> assignment SEMICOLON .)
    BOOL            reduce using rule 5 (statement -> assignment SEMICOLON .)
    NULL            reduce using rule 5 (statement -> assignment SEMICOLON .)
    ID              reduce using rule 5 (statement -> assignment SEMICOLON .)
    LPAREN          reduce using rule 5 (statement -> assignment SEMICOLON .)
    LBRACKET        reduce using rule 5 (statement -> assignment SEMICOLON .)
    LBRACE          reduce using rule 5 (statement -> assignment SEMICOLON .)
    PLACEHOLDER     reduce using rule 5 (statement -> assignment SEMICOLON .)
    MAC             reduce using rule 5 (statement -> assignment SEMICOLON .)
    ATOM            reduce using rule 5 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 5 (statement -> assignment SEMICOLON .)
    FUN             reduce using rule 5 (statement -> assignment SEMICOLON .)
    NOT             reduce using rule 5 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 5 (statement -> assignment SEMICOLON .)
    RPAREN          reduce using rule 5 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 5 (statement -> assignment SEMICOLON .)


state 37

    (7) statement -> expr SEMICOLON .

    IMPORT          reduce using rule 7 (statement -> expr SEMICOLON .)
    RETURN          reduce using rule 7 (statement -> expr SEMICOLON .)
    IF              reduce using rule 7 (statement -> expr SEMICOLON .)
    STRING          reduce using rule 7 (statement -> expr SEMICOLON .)
    NUMBER          reduce using rule 7 (statement -> expr SEMICOLON .)
    BOOL            reduce using rule 7 (statement -> expr SEMICOLON .)
    NULL            reduce using rule 7 (statement -> expr SEMICOLON .)
    ID              reduce using rule 7 (statement -> expr SEMICOLON .)
    LPAREN          reduce using rule 7 (statement -> expr SEMICOLON .)
    LBRACKET        reduce using rule 7 (statement -> expr SEMICOLON .)
    LBRACE          reduce using rule 7 (statement -> expr SEMICOLON .)
    PLACEHOLDER     reduce using rule 7 (statement -> expr SEMICOLON .)
    MAC             reduce using rule 7 (statement -> expr SEMICOLON .)
    ATOM            reduce using rule 7 (statement -> expr SEMICOLON .)
    WHILE           reduce using rule 7 (statement -> expr SEMICOLON .)
    FUN             reduce using rule 7 (statement -> expr SEMICOLON .)
    NOT             reduce using rule 7 (statement -> expr SEMICOLON .)
    $end            reduce using rule 7 (statement -> expr SEMICOLON .)
    RPAREN          reduce using rule 7 (statement -> expr SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> expr SEMICOLON .)


state 38

    (54) expr -> expr LBRACKET . expr RBRACKET
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 79
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 39

    (44) alg_op -> expr PLUS . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 80
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 40

    (45) alg_op -> expr MINUS . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 81
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 41

    (46) alg_op -> expr MULTIPLY . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 82
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 42

    (47) alg_op -> expr DIVIDE . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 83
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 43

    (57) comp_op -> expr EQUAL . EQUAL expr

    EQUAL           shift and go to state 84


state 44

    (58) comp_op -> expr BANG . EQUAL expr

    EQUAL           shift and go to state 85


state 45

    (59) comp_op -> expr GT . expr
    (60) comp_op -> expr GT . EQUAL expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    EQUAL           shift and go to state 87
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 86
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 46

    (61) comp_op -> expr LT . expr
    (62) comp_op -> expr LT . EQUAL expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    EQUAL           shift and go to state 89
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 88
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 47

    (64) log_op -> expr AND . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 90
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 48

    (65) log_op -> expr OR . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 91
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 49

    (15) statement -> RETURN expr . SEMICOLON
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       shift and go to state 92
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 50

    (37) expr -> ID .
    (40) func_call -> ID . LPAREN arg_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    SEMICOLON       reduce using rule 37 (expr -> ID .)
    LBRACKET        reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    MULTIPLY        reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    EQUAL           reduce using rule 37 (expr -> ID .)
    BANG            reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    AND             reduce using rule 37 (expr -> ID .)
    OR              reduce using rule 37 (expr -> ID .)
    COMMA           reduce using rule 37 (expr -> ID .)
    RBRACKET        reduce using rule 37 (expr -> ID .)
    ATOM            reduce using rule 37 (expr -> ID .)
    STRING          reduce using rule 37 (expr -> ID .)
    NUMBER          reduce using rule 37 (expr -> ID .)
    BOOL            reduce using rule 37 (expr -> ID .)
    NULL            reduce using rule 37 (expr -> ID .)
    ID              reduce using rule 37 (expr -> ID .)
    LBRACE          reduce using rule 37 (expr -> ID .)
    PLACEHOLDER     reduce using rule 37 (expr -> ID .)
    NOT             reduce using rule 37 (expr -> ID .)
    RPAREN          reduce using rule 37 (expr -> ID .)
    RBRACE          reduce using rule 37 (expr -> ID .)
    LPAREN          shift and go to state 63

  ! LPAREN          [ reduce using rule 37 (expr -> ID .) ]


state 51

    (56) expr -> PLACEHOLDER .

    SEMICOLON       reduce using rule 56 (expr -> PLACEHOLDER .)
    LBRACKET        reduce using rule 56 (expr -> PLACEHOLDER .)
    PLUS            reduce using rule 56 (expr -> PLACEHOLDER .)
    MINUS           reduce using rule 56 (expr -> PLACEHOLDER .)
    MULTIPLY        reduce using rule 56 (expr -> PLACEHOLDER .)
    DIVIDE          reduce using rule 56 (expr -> PLACEHOLDER .)
    EQUAL           reduce using rule 56 (expr -> PLACEHOLDER .)
    BANG            reduce using rule 56 (expr -> PLACEHOLDER .)
    GT              reduce using rule 56 (expr -> PLACEHOLDER .)
    LT              reduce using rule 56 (expr -> PLACEHOLDER .)
    AND             reduce using rule 56 (expr -> PLACEHOLDER .)
    OR              reduce using rule 56 (expr -> PLACEHOLDER .)
    COMMA           reduce using rule 56 (expr -> PLACEHOLDER .)
    RBRACKET        reduce using rule 56 (expr -> PLACEHOLDER .)
    ATOM            reduce using rule 56 (expr -> PLACEHOLDER .)
    STRING          reduce using rule 56 (expr -> PLACEHOLDER .)
    NUMBER          reduce using rule 56 (expr -> PLACEHOLDER .)
    BOOL            reduce using rule 56 (expr -> PLACEHOLDER .)
    NULL            reduce using rule 56 (expr -> PLACEHOLDER .)
    ID              reduce using rule 56 (expr -> PLACEHOLDER .)
    LPAREN          reduce using rule 56 (expr -> PLACEHOLDER .)
    LBRACE          reduce using rule 56 (expr -> PLACEHOLDER .)
    PLACEHOLDER     reduce using rule 56 (expr -> PLACEHOLDER .)
    NOT             reduce using rule 56 (expr -> PLACEHOLDER .)
    RPAREN          reduce using rule 56 (expr -> PLACEHOLDER .)
    RBRACE          reduce using rule 56 (expr -> PLACEHOLDER .)


state 52

    (10) assignment -> l_value EQUAL . r_value
    (24) r_value -> . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    r_value                        shift and go to state 93
    expr                           shift and go to state 94
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 53

    (19) conditional -> IF LPAREN . expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 95
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 54

    (38) expr -> LPAREN expr . RPAREN
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr
    (7) statement -> expr . SEMICOLON

    RPAREN          shift and go to state 96
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48
    SEMICOLON       shift and go to state 37


state 55

    (50) expr -> LPAREN statement_list . RPAREN

    RPAREN          shift and go to state 97


state 56

    (76) anonymous_fun -> LPAREN id_list . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 98


state 57

    (37) expr -> ID .
    (16) id_list -> ID .
    (17) id_list -> ID . COMMA id_list
    (40) func_call -> ID . LPAREN arg_list RPAREN
    (25) l_value -> ID .
    (26) l_value -> ID . fields
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

  ! reduce/reduce conflict for RPAREN resolved using rule 16 (id_list -> ID .)
  ! reduce/reduce conflict for EQUAL resolved using rule 25 (l_value -> ID .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    MULTIPLY        reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    BANG            reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    AND             reduce using rule 37 (expr -> ID .)
    OR              reduce using rule 37 (expr -> ID .)
    SEMICOLON       reduce using rule 37 (expr -> ID .)
    RPAREN          reduce using rule 16 (id_list -> ID .)
    COMMA           shift and go to state 99
    LPAREN          shift and go to state 63
    EQUAL           reduce using rule 25 (l_value -> ID .)
    LBRACKET        shift and go to state 64

  ! RPAREN          [ reduce using rule 37 (expr -> ID .) ]
  ! LBRACKET        [ reduce using rule 37 (expr -> ID .) ]
  ! EQUAL           [ reduce using rule 37 (expr -> ID .) ]

    fields                         shift and go to state 62

state 58

    (2) statement_list -> empty .
    (18) id_list -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 2 (statement_list -> empty .)
    RPAREN          reduce using rule 2 (statement_list -> empty .)

  ! RPAREN          [ reduce using rule 18 (id_list -> empty .) ]


state 59

    (49) expr -> LBRACE record_list . RBRACE

    RBRACE          shift and go to state 100


state 60

    (51) record_list -> ID . COLON expr
    (52) record_list -> ID . COLON expr COMMA record_list

    COLON           shift and go to state 101


state 61

    (53) record_list -> empty .

    RBRACE          reduce using rule 53 (record_list -> empty .)


state 62

    (26) l_value -> ID fields .

    EQUAL           reduce using rule 26 (l_value -> ID fields .)


state 63

    (40) func_call -> ID LPAREN . arg_list RPAREN
    (41) arg_list -> . empty
    (42) arg_list -> . expr
    (43) arg_list -> . expr COMMA arg_list
    (3) empty -> .
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    RPAREN          reduce using rule 3 (empty -> .)
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    arg_list                       shift and go to state 102
    empty                          shift and go to state 66
    expr                           shift and go to state 67
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 64

    (29) fields -> LBRACKET . expr RBRACKET
    (30) fields -> LBRACKET . expr RBRACKET fields
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 103
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 65

    (48) expr -> LBRACKET arg_list . RBRACKET

    RBRACKET        shift and go to state 104


state 66

    (41) arg_list -> empty .

    RBRACKET        reduce using rule 41 (arg_list -> empty .)
    RPAREN          reduce using rule 41 (arg_list -> empty .)


state 67

    (42) arg_list -> expr .
    (43) arg_list -> expr . COMMA arg_list
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RBRACKET        reduce using rule 42 (arg_list -> expr .)
    RPAREN          reduce using rule 42 (arg_list -> expr .)
    COMMA           shift and go to state 105
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 68

    (28) l_value -> PLACEHOLDER fields .

    EQUAL           reduce using rule 28 (l_value -> PLACEHOLDER fields .)


state 69

    (67) macro_def -> MAC macro_def_arg_list . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 106


state 70

    (68) macro_def_arg_list -> ATOM . macro_def_arg_list_rec
    (69) macro_def_arg_list_rec -> . PLACEHOLDER macro_def_arg_list_rec
    (70) macro_def_arg_list_rec -> . ATOM macro_def_arg_list_rec
    (71) macro_def_arg_list_rec -> . empty
    (3) empty -> .

    PLACEHOLDER     shift and go to state 109
    ATOM            shift and go to state 107
    LBRACE          reduce using rule 3 (empty -> .)

    macro_def_arg_list_rec         shift and go to state 108
    empty                          shift and go to state 110

state 71

    (73) macro_arg_list -> ATOM . macro_arg_list
    (73) macro_arg_list -> . ATOM macro_arg_list
    (74) macro_arg_list -> . expr macro_arg_list
    (75) macro_arg_list -> . empty
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (3) empty -> .
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    ATOM            shift and go to state 71
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    SEMICOLON       reduce using rule 3 (empty -> .)
    NOT             shift and go to state 33

    macro_arg_list                 shift and go to state 111
    expr                           shift and go to state 73
    empty                          shift and go to state 74
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 72

    (72) macro_call -> ATOM macro_arg_list . SEMICOLON

    SEMICOLON       shift and go to state 112


state 73

    (74) macro_arg_list -> expr . macro_arg_list
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr
    (73) macro_arg_list -> . ATOM macro_arg_list
    (74) macro_arg_list -> . expr macro_arg_list
    (75) macro_arg_list -> . empty
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (3) empty -> .
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    LBRACKET        shift and go to state 114
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48
    ATOM            shift and go to state 71
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    SEMICOLON       reduce using rule 3 (empty -> .)
    NOT             shift and go to state 33

    expr                           shift and go to state 73
    macro_arg_list                 shift and go to state 113
    empty                          shift and go to state 74
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 74

    (75) macro_arg_list -> empty .

    SEMICOLON       reduce using rule 75 (macro_arg_list -> empty .)


state 75

    (12) loop -> WHILE LPAREN . expr RPAREN LBRACE statement_list RBRACE
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 115
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 76

    (14) fun_def -> FUN ID . LPAREN id_list RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 116


state 77

    (66) log_op -> NOT expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 66 (log_op -> NOT expr .)
    RPAREN          reduce using rule 66 (log_op -> NOT expr .)
    COMMA           reduce using rule 66 (log_op -> NOT expr .)
    RBRACKET        reduce using rule 66 (log_op -> NOT expr .)
    ATOM            reduce using rule 66 (log_op -> NOT expr .)
    STRING          reduce using rule 66 (log_op -> NOT expr .)
    NUMBER          reduce using rule 66 (log_op -> NOT expr .)
    BOOL            reduce using rule 66 (log_op -> NOT expr .)
    NULL            reduce using rule 66 (log_op -> NOT expr .)
    ID              reduce using rule 66 (log_op -> NOT expr .)
    LPAREN          reduce using rule 66 (log_op -> NOT expr .)
    LBRACE          reduce using rule 66 (log_op -> NOT expr .)
    PLACEHOLDER     reduce using rule 66 (log_op -> NOT expr .)
    NOT             reduce using rule 66 (log_op -> NOT expr .)
    RBRACE          reduce using rule 66 (log_op -> NOT expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! PLUS            [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! MINUS           [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! MULTIPLY        [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! DIVIDE          [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! EQUAL           [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! BANG            [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! GT              [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! LT              [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! AND             [ reduce using rule 66 (log_op -> NOT expr .) ]
  ! OR              [ reduce using rule 66 (log_op -> NOT expr .) ]


state 78

    (4) statement -> IMPORT STRING SEMICOLON .

    IMPORT          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    RETURN          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    IF              reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    STRING          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    NUMBER          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    BOOL            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    NULL            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    ID              reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    LBRACKET        reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    LBRACE          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    PLACEHOLDER     reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    MAC             reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    ATOM            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    FUN             reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    NOT             reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    $end            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    RPAREN          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)


state 79

    (54) expr -> expr LBRACKET expr . RBRACKET
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RBRACKET        shift and go to state 117
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 80

    (44) alg_op -> expr PLUS expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 44 (alg_op -> expr PLUS expr .)
    LBRACKET        reduce using rule 44 (alg_op -> expr PLUS expr .)
    PLUS            reduce using rule 44 (alg_op -> expr PLUS expr .)
    MINUS           reduce using rule 44 (alg_op -> expr PLUS expr .)
    EQUAL           reduce using rule 44 (alg_op -> expr PLUS expr .)
    BANG            reduce using rule 44 (alg_op -> expr PLUS expr .)
    GT              reduce using rule 44 (alg_op -> expr PLUS expr .)
    LT              reduce using rule 44 (alg_op -> expr PLUS expr .)
    AND             reduce using rule 44 (alg_op -> expr PLUS expr .)
    OR              reduce using rule 44 (alg_op -> expr PLUS expr .)
    RPAREN          reduce using rule 44 (alg_op -> expr PLUS expr .)
    COMMA           reduce using rule 44 (alg_op -> expr PLUS expr .)
    RBRACKET        reduce using rule 44 (alg_op -> expr PLUS expr .)
    ATOM            reduce using rule 44 (alg_op -> expr PLUS expr .)
    STRING          reduce using rule 44 (alg_op -> expr PLUS expr .)
    NUMBER          reduce using rule 44 (alg_op -> expr PLUS expr .)
    BOOL            reduce using rule 44 (alg_op -> expr PLUS expr .)
    NULL            reduce using rule 44 (alg_op -> expr PLUS expr .)
    ID              reduce using rule 44 (alg_op -> expr PLUS expr .)
    LPAREN          reduce using rule 44 (alg_op -> expr PLUS expr .)
    LBRACE          reduce using rule 44 (alg_op -> expr PLUS expr .)
    PLACEHOLDER     reduce using rule 44 (alg_op -> expr PLUS expr .)
    NOT             reduce using rule 44 (alg_op -> expr PLUS expr .)
    RBRACE          reduce using rule 44 (alg_op -> expr PLUS expr .)
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42

  ! MULTIPLY        [ reduce using rule 44 (alg_op -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 44 (alg_op -> expr PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! EQUAL           [ shift and go to state 43 ]
  ! BANG            [ shift and go to state 44 ]
  ! GT              [ shift and go to state 45 ]
  ! LT              [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 81

    (45) alg_op -> expr MINUS expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 45 (alg_op -> expr MINUS expr .)
    LBRACKET        reduce using rule 45 (alg_op -> expr MINUS expr .)
    PLUS            reduce using rule 45 (alg_op -> expr MINUS expr .)
    MINUS           reduce using rule 45 (alg_op -> expr MINUS expr .)
    EQUAL           reduce using rule 45 (alg_op -> expr MINUS expr .)
    BANG            reduce using rule 45 (alg_op -> expr MINUS expr .)
    GT              reduce using rule 45 (alg_op -> expr MINUS expr .)
    LT              reduce using rule 45 (alg_op -> expr MINUS expr .)
    AND             reduce using rule 45 (alg_op -> expr MINUS expr .)
    OR              reduce using rule 45 (alg_op -> expr MINUS expr .)
    RPAREN          reduce using rule 45 (alg_op -> expr MINUS expr .)
    COMMA           reduce using rule 45 (alg_op -> expr MINUS expr .)
    RBRACKET        reduce using rule 45 (alg_op -> expr MINUS expr .)
    ATOM            reduce using rule 45 (alg_op -> expr MINUS expr .)
    STRING          reduce using rule 45 (alg_op -> expr MINUS expr .)
    NUMBER          reduce using rule 45 (alg_op -> expr MINUS expr .)
    BOOL            reduce using rule 45 (alg_op -> expr MINUS expr .)
    NULL            reduce using rule 45 (alg_op -> expr MINUS expr .)
    ID              reduce using rule 45 (alg_op -> expr MINUS expr .)
    LPAREN          reduce using rule 45 (alg_op -> expr MINUS expr .)
    LBRACE          reduce using rule 45 (alg_op -> expr MINUS expr .)
    PLACEHOLDER     reduce using rule 45 (alg_op -> expr MINUS expr .)
    NOT             reduce using rule 45 (alg_op -> expr MINUS expr .)
    RBRACE          reduce using rule 45 (alg_op -> expr MINUS expr .)
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42

  ! MULTIPLY        [ reduce using rule 45 (alg_op -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 45 (alg_op -> expr MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! EQUAL           [ shift and go to state 43 ]
  ! BANG            [ shift and go to state 44 ]
  ! GT              [ shift and go to state 45 ]
  ! LT              [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 82

    (46) alg_op -> expr MULTIPLY expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    LBRACKET        reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    PLUS            reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    MINUS           reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    MULTIPLY        reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    DIVIDE          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    EQUAL           reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    BANG            reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    GT              reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    LT              reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    AND             reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    OR              reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    COMMA           reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    RBRACKET        reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    ATOM            reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    STRING          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    NUMBER          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    BOOL            reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    NULL            reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    ID              reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    LPAREN          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    LBRACE          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    PLACEHOLDER     reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    NOT             reduce using rule 46 (alg_op -> expr MULTIPLY expr .)
    RBRACE          reduce using rule 46 (alg_op -> expr MULTIPLY expr .)

  ! LBRACKET        [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! MULTIPLY        [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! EQUAL           [ shift and go to state 43 ]
  ! BANG            [ shift and go to state 44 ]
  ! GT              [ shift and go to state 45 ]
  ! LT              [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 83

    (47) alg_op -> expr DIVIDE expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    PLUS            reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    MINUS           reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    MULTIPLY        reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    EQUAL           reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    BANG            reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    GT              reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    LT              reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    AND             reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    OR              reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    RPAREN          reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    COMMA           reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    ATOM            reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    STRING          reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    NUMBER          reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    BOOL            reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    NULL            reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    ID              reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    LPAREN          reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    LBRACE          reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    PLACEHOLDER     reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    NOT             reduce using rule 47 (alg_op -> expr DIVIDE expr .)
    RBRACE          reduce using rule 47 (alg_op -> expr DIVIDE expr .)

  ! LBRACKET        [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! MULTIPLY        [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! EQUAL           [ shift and go to state 43 ]
  ! BANG            [ shift and go to state 44 ]
  ! GT              [ shift and go to state 45 ]
  ! LT              [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 84

    (57) comp_op -> expr EQUAL EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 118
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 85

    (58) comp_op -> expr BANG EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 119
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 86

    (59) comp_op -> expr GT expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 59 (comp_op -> expr GT expr .)
    RPAREN          reduce using rule 59 (comp_op -> expr GT expr .)
    COMMA           reduce using rule 59 (comp_op -> expr GT expr .)
    RBRACKET        reduce using rule 59 (comp_op -> expr GT expr .)
    ATOM            reduce using rule 59 (comp_op -> expr GT expr .)
    STRING          reduce using rule 59 (comp_op -> expr GT expr .)
    NUMBER          reduce using rule 59 (comp_op -> expr GT expr .)
    BOOL            reduce using rule 59 (comp_op -> expr GT expr .)
    NULL            reduce using rule 59 (comp_op -> expr GT expr .)
    ID              reduce using rule 59 (comp_op -> expr GT expr .)
    LPAREN          reduce using rule 59 (comp_op -> expr GT expr .)
    LBRACE          reduce using rule 59 (comp_op -> expr GT expr .)
    PLACEHOLDER     reduce using rule 59 (comp_op -> expr GT expr .)
    NOT             reduce using rule 59 (comp_op -> expr GT expr .)
    RBRACE          reduce using rule 59 (comp_op -> expr GT expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! EQUAL           [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! BANG            [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! GT              [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! LT              [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! AND             [ reduce using rule 59 (comp_op -> expr GT expr .) ]
  ! OR              [ reduce using rule 59 (comp_op -> expr GT expr .) ]


state 87

    (60) comp_op -> expr GT EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 120
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 88

    (61) comp_op -> expr LT expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 61 (comp_op -> expr LT expr .)
    RPAREN          reduce using rule 61 (comp_op -> expr LT expr .)
    COMMA           reduce using rule 61 (comp_op -> expr LT expr .)
    RBRACKET        reduce using rule 61 (comp_op -> expr LT expr .)
    ATOM            reduce using rule 61 (comp_op -> expr LT expr .)
    STRING          reduce using rule 61 (comp_op -> expr LT expr .)
    NUMBER          reduce using rule 61 (comp_op -> expr LT expr .)
    BOOL            reduce using rule 61 (comp_op -> expr LT expr .)
    NULL            reduce using rule 61 (comp_op -> expr LT expr .)
    ID              reduce using rule 61 (comp_op -> expr LT expr .)
    LPAREN          reduce using rule 61 (comp_op -> expr LT expr .)
    LBRACE          reduce using rule 61 (comp_op -> expr LT expr .)
    PLACEHOLDER     reduce using rule 61 (comp_op -> expr LT expr .)
    NOT             reduce using rule 61 (comp_op -> expr LT expr .)
    RBRACE          reduce using rule 61 (comp_op -> expr LT expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! EQUAL           [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! BANG            [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! GT              [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! LT              [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! AND             [ reduce using rule 61 (comp_op -> expr LT expr .) ]
  ! OR              [ reduce using rule 61 (comp_op -> expr LT expr .) ]


state 89

    (62) comp_op -> expr LT EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 121
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 90

    (64) log_op -> expr AND expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 64 (log_op -> expr AND expr .)
    RPAREN          reduce using rule 64 (log_op -> expr AND expr .)
    COMMA           reduce using rule 64 (log_op -> expr AND expr .)
    RBRACKET        reduce using rule 64 (log_op -> expr AND expr .)
    ATOM            reduce using rule 64 (log_op -> expr AND expr .)
    STRING          reduce using rule 64 (log_op -> expr AND expr .)
    NUMBER          reduce using rule 64 (log_op -> expr AND expr .)
    BOOL            reduce using rule 64 (log_op -> expr AND expr .)
    NULL            reduce using rule 64 (log_op -> expr AND expr .)
    ID              reduce using rule 64 (log_op -> expr AND expr .)
    LPAREN          reduce using rule 64 (log_op -> expr AND expr .)
    LBRACE          reduce using rule 64 (log_op -> expr AND expr .)
    PLACEHOLDER     reduce using rule 64 (log_op -> expr AND expr .)
    NOT             reduce using rule 64 (log_op -> expr AND expr .)
    RBRACE          reduce using rule 64 (log_op -> expr AND expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! MULTIPLY        [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! EQUAL           [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! BANG            [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! GT              [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! LT              [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! AND             [ reduce using rule 64 (log_op -> expr AND expr .) ]
  ! OR              [ reduce using rule 64 (log_op -> expr AND expr .) ]


state 91

    (65) log_op -> expr OR expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 65 (log_op -> expr OR expr .)
    RPAREN          reduce using rule 65 (log_op -> expr OR expr .)
    COMMA           reduce using rule 65 (log_op -> expr OR expr .)
    RBRACKET        reduce using rule 65 (log_op -> expr OR expr .)
    ATOM            reduce using rule 65 (log_op -> expr OR expr .)
    STRING          reduce using rule 65 (log_op -> expr OR expr .)
    NUMBER          reduce using rule 65 (log_op -> expr OR expr .)
    BOOL            reduce using rule 65 (log_op -> expr OR expr .)
    NULL            reduce using rule 65 (log_op -> expr OR expr .)
    ID              reduce using rule 65 (log_op -> expr OR expr .)
    LPAREN          reduce using rule 65 (log_op -> expr OR expr .)
    LBRACE          reduce using rule 65 (log_op -> expr OR expr .)
    PLACEHOLDER     reduce using rule 65 (log_op -> expr OR expr .)
    NOT             reduce using rule 65 (log_op -> expr OR expr .)
    RBRACE          reduce using rule 65 (log_op -> expr OR expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! MULTIPLY        [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! EQUAL           [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! BANG            [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! GT              [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! LT              [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! AND             [ reduce using rule 65 (log_op -> expr OR expr .) ]
  ! OR              [ reduce using rule 65 (log_op -> expr OR expr .) ]


state 92

    (15) statement -> RETURN expr SEMICOLON .

    IMPORT          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    IF              reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    NUMBER          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    BOOL            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    ID              reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    LBRACKET        reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    PLACEHOLDER     reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    MAC             reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    ATOM            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    FUN             reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    $end            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    RPAREN          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)


state 93

    (10) assignment -> l_value EQUAL r_value .

    SEMICOLON       reduce using rule 10 (assignment -> l_value EQUAL r_value .)


state 94

    (24) r_value -> expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 24 (r_value -> expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 95

    (19) conditional -> IF LPAREN expr . RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RPAREN          shift and go to state 122
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 96

    (38) expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    BANG            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    ATOM            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    STRING          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NUMBER          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    BOOL            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NULL            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    PLACEHOLDER     reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NOT             reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)


state 97

    (50) expr -> LPAREN statement_list RPAREN .

    SEMICOLON       reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    LBRACKET        reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    PLUS            reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    MINUS           reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    MULTIPLY        reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    DIVIDE          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    EQUAL           reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    BANG            reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    GT              reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    LT              reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    AND             reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    OR              reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    RPAREN          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    COMMA           reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    RBRACKET        reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    ATOM            reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    STRING          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    NUMBER          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    BOOL            reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    NULL            reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    ID              reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    LPAREN          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    LBRACE          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    PLACEHOLDER     reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    NOT             reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)
    RBRACE          reduce using rule 50 (expr -> LPAREN statement_list RPAREN .)


state 98

    (76) anonymous_fun -> LPAREN id_list RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 123


state 99

    (17) id_list -> ID COMMA . id_list
    (16) id_list -> . ID
    (17) id_list -> . ID COMMA id_list
    (18) id_list -> . empty
    (3) empty -> .

    ID              shift and go to state 124
    RPAREN          reduce using rule 3 (empty -> .)

    id_list                        shift and go to state 125
    empty                          shift and go to state 126

state 100

    (49) expr -> LBRACE record_list RBRACE .

    SEMICOLON       reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    LBRACKET        reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    PLUS            reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    MINUS           reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    MULTIPLY        reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    DIVIDE          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    EQUAL           reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    BANG            reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    GT              reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    LT              reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    AND             reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    OR              reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    RPAREN          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    COMMA           reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    RBRACKET        reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    ATOM            reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    STRING          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    NUMBER          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    BOOL            reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    NULL            reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    ID              reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    LPAREN          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    LBRACE          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    PLACEHOLDER     reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    NOT             reduce using rule 49 (expr -> LBRACE record_list RBRACE .)
    RBRACE          reduce using rule 49 (expr -> LBRACE record_list RBRACE .)


state 101

    (51) record_list -> ID COLON . expr
    (52) record_list -> ID COLON . expr COMMA record_list
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 127
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 102

    (40) func_call -> ID LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 128


state 103

    (29) fields -> LBRACKET expr . RBRACKET
    (30) fields -> LBRACKET expr . RBRACKET fields
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RBRACKET        shift and go to state 129
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 104

    (48) expr -> LBRACKET arg_list RBRACKET .

    SEMICOLON       reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    LBRACKET        reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    PLUS            reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    MINUS           reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    MULTIPLY        reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    DIVIDE          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    EQUAL           reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    BANG            reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    GT              reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    LT              reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    AND             reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    OR              reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    RPAREN          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    COMMA           reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    RBRACKET        reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    ATOM            reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    STRING          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    NUMBER          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    BOOL            reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    NULL            reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    ID              reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    LPAREN          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    LBRACE          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    PLACEHOLDER     reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    NOT             reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)
    RBRACE          reduce using rule 48 (expr -> LBRACKET arg_list RBRACKET .)


state 105

    (43) arg_list -> expr COMMA . arg_list
    (41) arg_list -> . empty
    (42) arg_list -> . expr
    (43) arg_list -> . expr COMMA arg_list
    (3) empty -> .
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    RBRACKET        reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 67
    arg_list                       shift and go to state 130
    empty                          shift and go to state 66
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 106

    (67) macro_def -> MAC macro_def_arg_list LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    statement_list                 shift and go to state 131
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 107

    (70) macro_def_arg_list_rec -> ATOM . macro_def_arg_list_rec
    (69) macro_def_arg_list_rec -> . PLACEHOLDER macro_def_arg_list_rec
    (70) macro_def_arg_list_rec -> . ATOM macro_def_arg_list_rec
    (71) macro_def_arg_list_rec -> . empty
    (3) empty -> .

    PLACEHOLDER     shift and go to state 109
    ATOM            shift and go to state 107
    LBRACE          reduce using rule 3 (empty -> .)

    macro_def_arg_list_rec         shift and go to state 132
    empty                          shift and go to state 110

state 108

    (68) macro_def_arg_list -> ATOM macro_def_arg_list_rec .

    LBRACE          reduce using rule 68 (macro_def_arg_list -> ATOM macro_def_arg_list_rec .)


state 109

    (69) macro_def_arg_list_rec -> PLACEHOLDER . macro_def_arg_list_rec
    (69) macro_def_arg_list_rec -> . PLACEHOLDER macro_def_arg_list_rec
    (70) macro_def_arg_list_rec -> . ATOM macro_def_arg_list_rec
    (71) macro_def_arg_list_rec -> . empty
    (3) empty -> .

    PLACEHOLDER     shift and go to state 109
    ATOM            shift and go to state 107
    LBRACE          reduce using rule 3 (empty -> .)

    macro_def_arg_list_rec         shift and go to state 133
    empty                          shift and go to state 110

state 110

    (71) macro_def_arg_list_rec -> empty .

    LBRACE          reduce using rule 71 (macro_def_arg_list_rec -> empty .)


state 111

    (73) macro_arg_list -> ATOM macro_arg_list .

    SEMICOLON       reduce using rule 73 (macro_arg_list -> ATOM macro_arg_list .)


state 112

    (72) macro_call -> ATOM macro_arg_list SEMICOLON .

    IMPORT          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    RETURN          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    IF              reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    STRING          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    NUMBER          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    BOOL            reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    NULL            reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    ID              reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    LPAREN          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    LBRACKET        reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    LBRACE          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    PLACEHOLDER     reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    MAC             reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    ATOM            reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    WHILE           reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    FUN             reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    NOT             reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    $end            reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    RPAREN          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    RBRACE          reduce using rule 72 (macro_call -> ATOM macro_arg_list SEMICOLON .)


state 113

    (74) macro_arg_list -> expr macro_arg_list .

    SEMICOLON       reduce using rule 74 (macro_arg_list -> expr macro_arg_list .)


state 114

    (54) expr -> expr LBRACKET . expr RBRACKET
    (48) expr -> LBRACKET . arg_list RBRACKET
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (41) arg_list -> . empty
    (42) arg_list -> . expr
    (43) arg_list -> . expr COMMA arg_list
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr
    (3) empty -> .

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33
    RBRACKET        reduce using rule 3 (empty -> .)

    expr                           shift and go to state 134
    arg_list                       shift and go to state 65
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28
    empty                          shift and go to state 66

state 115

    (12) loop -> WHILE LPAREN expr . RPAREN LBRACE statement_list RBRACE
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RPAREN          shift and go to state 135
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 116

    (14) fun_def -> FUN ID LPAREN . id_list RPAREN LBRACE statement_list RBRACE
    (16) id_list -> . ID
    (17) id_list -> . ID COMMA id_list
    (18) id_list -> . empty
    (3) empty -> .

    ID              shift and go to state 124
    RPAREN          reduce using rule 3 (empty -> .)

    id_list                        shift and go to state 136
    empty                          shift and go to state 126

state 117

    (54) expr -> expr LBRACKET expr RBRACKET .

    SEMICOLON       reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    MULTIPLY        reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    BANG            reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    AND             reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    OR              reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    ATOM            reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    STRING          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    NUMBER          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    BOOL            reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    NULL            reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    ID              reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    PLACEHOLDER     reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    NOT             reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 54 (expr -> expr LBRACKET expr RBRACKET .)


state 118

    (57) comp_op -> expr EQUAL EQUAL expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    RPAREN          reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    COMMA           reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    RBRACKET        reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    ATOM            reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    STRING          reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    NUMBER          reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    BOOL            reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    NULL            reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    ID              reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    LPAREN          reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    LBRACE          reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    PLACEHOLDER     reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    NOT             reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    RBRACE          reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! PLUS            [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! MINUS           [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! BANG            [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! GT              [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! LT              [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! AND             [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! OR              [ reduce using rule 57 (comp_op -> expr EQUAL EQUAL expr .) ]


state 119

    (58) comp_op -> expr BANG EQUAL expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    RPAREN          reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    COMMA           reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    RBRACKET        reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    ATOM            reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    STRING          reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    NUMBER          reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    BOOL            reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    NULL            reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    ID              reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    LPAREN          reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    LBRACE          reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    PLACEHOLDER     reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    NOT             reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    RBRACE          reduce using rule 58 (comp_op -> expr BANG EQUAL expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! PLUS            [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! MINUS           [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! BANG            [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! GT              [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! LT              [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! AND             [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]
  ! OR              [ reduce using rule 58 (comp_op -> expr BANG EQUAL expr .) ]


state 120

    (60) comp_op -> expr GT EQUAL expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    RPAREN          reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    COMMA           reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    RBRACKET        reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    ATOM            reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    STRING          reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    NUMBER          reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    BOOL            reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    NULL            reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    ID              reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    LPAREN          reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    LBRACE          reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    PLACEHOLDER     reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    NOT             reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    RBRACE          reduce using rule 60 (comp_op -> expr GT EQUAL expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! PLUS            [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! MINUS           [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! BANG            [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! GT              [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! LT              [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! AND             [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]
  ! OR              [ reduce using rule 60 (comp_op -> expr GT EQUAL expr .) ]


state 121

    (62) comp_op -> expr LT EQUAL expr .
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    RPAREN          reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    COMMA           reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    RBRACKET        reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    ATOM            reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    STRING          reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    NUMBER          reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    BOOL            reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    NULL            reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    ID              reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    LPAREN          reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    LBRACE          reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    PLACEHOLDER     reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    NOT             reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    RBRACE          reduce using rule 62 (comp_op -> expr LT EQUAL expr .)
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! LBRACKET        [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! PLUS            [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! MINUS           [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! BANG            [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! GT              [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! LT              [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! AND             [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]
  ! OR              [ reduce using rule 62 (comp_op -> expr LT EQUAL expr .) ]


state 122

    (19) conditional -> IF LPAREN expr RPAREN . LBRACE statement_list RBRACE conditional_elif conditional_else

    LBRACE          shift and go to state 137


state 123

    (76) anonymous_fun -> LPAREN id_list RPAREN LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    statement_list                 shift and go to state 138
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 124

    (16) id_list -> ID .
    (17) id_list -> ID . COMMA id_list

    RPAREN          reduce using rule 16 (id_list -> ID .)
    COMMA           shift and go to state 99


state 125

    (17) id_list -> ID COMMA id_list .

    RPAREN          reduce using rule 17 (id_list -> ID COMMA id_list .)


state 126

    (18) id_list -> empty .

    RPAREN          reduce using rule 18 (id_list -> empty .)


state 127

    (51) record_list -> ID COLON expr .
    (52) record_list -> ID COLON expr . COMMA record_list
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RBRACE          reduce using rule 51 (record_list -> ID COLON expr .)
    COMMA           shift and go to state 139
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 128

    (40) func_call -> ID LPAREN arg_list RPAREN .

    SEMICOLON       reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    LBRACKET        reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    MULTIPLY        reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    EQUAL           reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    BANG            reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    GT              reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    LT              reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    AND             reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    OR              reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    ATOM            reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    STRING          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    NUMBER          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    BOOL            reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    NULL            reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    ID              reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    LPAREN          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    LBRACE          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    PLACEHOLDER     reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    NOT             reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 40 (func_call -> ID LPAREN arg_list RPAREN .)


state 129

    (29) fields -> LBRACKET expr RBRACKET .
    (30) fields -> LBRACKET expr RBRACKET . fields
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

    EQUAL           reduce using rule 29 (fields -> LBRACKET expr RBRACKET .)
    LBRACKET        shift and go to state 64

    fields                         shift and go to state 140

state 130

    (43) arg_list -> expr COMMA arg_list .

    RBRACKET        reduce using rule 43 (arg_list -> expr COMMA arg_list .)
    RPAREN          reduce using rule 43 (arg_list -> expr COMMA arg_list .)


state 131

    (67) macro_def -> MAC macro_def_arg_list LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 141


state 132

    (70) macro_def_arg_list_rec -> ATOM macro_def_arg_list_rec .

    LBRACE          reduce using rule 70 (macro_def_arg_list_rec -> ATOM macro_def_arg_list_rec .)


state 133

    (69) macro_def_arg_list_rec -> PLACEHOLDER macro_def_arg_list_rec .

    LBRACE          reduce using rule 69 (macro_def_arg_list_rec -> PLACEHOLDER macro_def_arg_list_rec .)


state 134

    (54) expr -> expr LBRACKET expr . RBRACKET
    (54) expr -> expr . LBRACKET expr RBRACKET
    (42) arg_list -> expr .
    (43) arg_list -> expr . COMMA arg_list
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 117
    LBRACKET        shift and go to state 38
    COMMA           shift and go to state 105
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! RBRACKET        [ reduce using rule 42 (arg_list -> expr .) ]


state 135

    (12) loop -> WHILE LPAREN expr RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 142


state 136

    (14) fun_def -> FUN ID LPAREN id_list . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 143


state 137

    (19) conditional -> IF LPAREN expr RPAREN LBRACE . statement_list RBRACE conditional_elif conditional_else
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    expr                           shift and go to state 8
    statement_list                 shift and go to state 144
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 138

    (76) anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 145


state 139

    (52) record_list -> ID COLON expr COMMA . record_list
    (51) record_list -> . ID COLON expr
    (52) record_list -> . ID COLON expr COMMA record_list
    (53) record_list -> . empty
    (3) empty -> .

    ID              shift and go to state 60
    RBRACE          reduce using rule 3 (empty -> .)

    record_list                    shift and go to state 146
    empty                          shift and go to state 61

state 140

    (30) fields -> LBRACKET expr RBRACKET fields .

    EQUAL           reduce using rule 30 (fields -> LBRACKET expr RBRACKET fields .)


state 141

    (67) macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    IF              reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    STRING          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    NULL            reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    ID              reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    MAC             reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    FUN             reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    NOT             reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    $end            reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 67 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)


state 142

    (12) loop -> WHILE LPAREN expr RPAREN LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    expr                           shift and go to state 8
    statement_list                 shift and go to state 147
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 143

    (14) fun_def -> FUN ID LPAREN id_list RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 148


state 144

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list . RBRACE conditional_elif conditional_else

    RBRACE          shift and go to state 149


state 145

    (76) anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .

    SEMICOLON       reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    MULTIPLY        reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    DIVIDE          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    EQUAL           reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    BANG            reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    GT              reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LT              reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    AND             reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    OR              reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    COMMA           reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RBRACKET        reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NULL            reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    ID              reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NOT             reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 76 (anonymous_fun -> LPAREN id_list RPAREN LBRACE statement_list RBRACE .)


state 146

    (52) record_list -> ID COLON expr COMMA record_list .

    RBRACE          reduce using rule 52 (record_list -> ID COLON expr COMMA record_list .)


state 147

    (12) loop -> WHILE LPAREN expr RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 150


state 148

    (14) fun_def -> FUN ID LPAREN id_list RPAREN LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    statement_list                 shift and go to state 151
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 149

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE . conditional_elif conditional_else
    (20) conditional_elif -> . ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif
    (21) conditional_elif -> . empty
    (3) empty -> .

    ELIF            shift and go to state 153
    ELSE            reduce using rule 3 (empty -> .)
    IMPORT          reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    NUMBER          reduce using rule 3 (empty -> .)
    BOOL            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    LBRACKET        reduce using rule 3 (empty -> .)
    LBRACE          reduce using rule 3 (empty -> .)
    PLACEHOLDER     reduce using rule 3 (empty -> .)
    MAC             reduce using rule 3 (empty -> .)
    ATOM            reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FUN             reduce using rule 3 (empty -> .)
    NOT             reduce using rule 3 (empty -> .)
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)

    conditional_elif               shift and go to state 152
    empty                          shift and go to state 154

state 150

    (12) loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    NULL            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    ID              reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    MAC             reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    FUN             reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    NOT             reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)


state 151

    (14) fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 155


state 152

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif . conditional_else
    (22) conditional_else -> . ELSE LBRACE statement_list RBRACE
    (23) conditional_else -> . empty
    (3) empty -> .

    ELSE            shift and go to state 157
    IMPORT          reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    NUMBER          reduce using rule 3 (empty -> .)
    BOOL            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    LBRACKET        reduce using rule 3 (empty -> .)
    LBRACE          reduce using rule 3 (empty -> .)
    PLACEHOLDER     reduce using rule 3 (empty -> .)
    MAC             reduce using rule 3 (empty -> .)
    ATOM            reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FUN             reduce using rule 3 (empty -> .)
    NOT             reduce using rule 3 (empty -> .)
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)

    conditional_else               shift and go to state 156
    empty                          shift and go to state 158

state 153

    (20) conditional_elif -> ELIF . LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif

    LPAREN          shift and go to state 159


state 154

    (21) conditional_elif -> empty .

    ELSE            reduce using rule 21 (conditional_elif -> empty .)
    IMPORT          reduce using rule 21 (conditional_elif -> empty .)
    RETURN          reduce using rule 21 (conditional_elif -> empty .)
    IF              reduce using rule 21 (conditional_elif -> empty .)
    STRING          reduce using rule 21 (conditional_elif -> empty .)
    NUMBER          reduce using rule 21 (conditional_elif -> empty .)
    BOOL            reduce using rule 21 (conditional_elif -> empty .)
    NULL            reduce using rule 21 (conditional_elif -> empty .)
    ID              reduce using rule 21 (conditional_elif -> empty .)
    LPAREN          reduce using rule 21 (conditional_elif -> empty .)
    LBRACKET        reduce using rule 21 (conditional_elif -> empty .)
    LBRACE          reduce using rule 21 (conditional_elif -> empty .)
    PLACEHOLDER     reduce using rule 21 (conditional_elif -> empty .)
    MAC             reduce using rule 21 (conditional_elif -> empty .)
    ATOM            reduce using rule 21 (conditional_elif -> empty .)
    WHILE           reduce using rule 21 (conditional_elif -> empty .)
    FUN             reduce using rule 21 (conditional_elif -> empty .)
    NOT             reduce using rule 21 (conditional_elif -> empty .)
    $end            reduce using rule 21 (conditional_elif -> empty .)
    RPAREN          reduce using rule 21 (conditional_elif -> empty .)
    RBRACE          reduce using rule 21 (conditional_elif -> empty .)


state 155

    (14) fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NULL            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    ID              reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    MAC             reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    FUN             reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NOT             reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)


state 156

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .

    IMPORT          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    RETURN          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    IF              reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    STRING          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    NUMBER          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    BOOL            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    NULL            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    ID              reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    LPAREN          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    LBRACKET        reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    LBRACE          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    PLACEHOLDER     reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    MAC             reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    ATOM            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    WHILE           reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    FUN             reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    NOT             reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    $end            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    RPAREN          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    RBRACE          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)


state 157

    (22) conditional_else -> ELSE . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 160


state 158

    (23) conditional_else -> empty .

    IMPORT          reduce using rule 23 (conditional_else -> empty .)
    RETURN          reduce using rule 23 (conditional_else -> empty .)
    IF              reduce using rule 23 (conditional_else -> empty .)
    STRING          reduce using rule 23 (conditional_else -> empty .)
    NUMBER          reduce using rule 23 (conditional_else -> empty .)
    BOOL            reduce using rule 23 (conditional_else -> empty .)
    NULL            reduce using rule 23 (conditional_else -> empty .)
    ID              reduce using rule 23 (conditional_else -> empty .)
    LPAREN          reduce using rule 23 (conditional_else -> empty .)
    LBRACKET        reduce using rule 23 (conditional_else -> empty .)
    LBRACE          reduce using rule 23 (conditional_else -> empty .)
    PLACEHOLDER     reduce using rule 23 (conditional_else -> empty .)
    MAC             reduce using rule 23 (conditional_else -> empty .)
    ATOM            reduce using rule 23 (conditional_else -> empty .)
    WHILE           reduce using rule 23 (conditional_else -> empty .)
    FUN             reduce using rule 23 (conditional_else -> empty .)
    NOT             reduce using rule 23 (conditional_else -> empty .)
    $end            reduce using rule 23 (conditional_else -> empty .)
    RPAREN          reduce using rule 23 (conditional_else -> empty .)
    RBRACE          reduce using rule 23 (conditional_else -> empty .)


state 159

    (20) conditional_elif -> ELIF LPAREN . expr RPAREN LBRACE statement_list RBRACE conditional_elif
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 50
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 51
    NOT             shift and go to state 33

    expr                           shift and go to state 161
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 160

    (22) conditional_else -> ELSE LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    statement_list                 shift and go to state 162
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 161

    (20) conditional_elif -> ELIF LPAREN expr . RPAREN LBRACE statement_list RBRACE conditional_elif
    (54) expr -> expr . LBRACKET expr RBRACKET
    (44) alg_op -> expr . PLUS expr
    (45) alg_op -> expr . MINUS expr
    (46) alg_op -> expr . MULTIPLY expr
    (47) alg_op -> expr . DIVIDE expr
    (57) comp_op -> expr . EQUAL EQUAL expr
    (58) comp_op -> expr . BANG EQUAL expr
    (59) comp_op -> expr . GT expr
    (60) comp_op -> expr . GT EQUAL expr
    (61) comp_op -> expr . LT expr
    (62) comp_op -> expr . LT EQUAL expr
    (64) log_op -> expr . AND expr
    (65) log_op -> expr . OR expr

    RPAREN          shift and go to state 163
    LBRACKET        shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    BANG            shift and go to state 44
    GT              shift and go to state 45
    LT              shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 162

    (22) conditional_else -> ELSE LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 164


state 163

    (20) conditional_elif -> ELIF LPAREN expr RPAREN . LBRACE statement_list RBRACE conditional_elif

    LBRACE          shift and go to state 165


state 164

    (22) conditional_else -> ELSE LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    STRING          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    NULL            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    ID              reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    MAC             reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    FUN             reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    NOT             reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    $end            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)


state 165

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE . statement_list RBRACE conditional_elif
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (39) expr -> . anonymous_fun
    (48) expr -> . LBRACKET arg_list RBRACKET
    (49) expr -> . LBRACE record_list RBRACE
    (50) expr -> . LPAREN statement_list RPAREN
    (54) expr -> . expr LBRACKET expr RBRACKET
    (55) expr -> . comp_op
    (56) expr -> . PLACEHOLDER
    (63) expr -> . log_op
    (67) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (72) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (44) alg_op -> . expr PLUS expr
    (45) alg_op -> . expr MINUS expr
    (46) alg_op -> . expr MULTIPLY expr
    (47) alg_op -> . expr DIVIDE expr
    (40) func_call -> . ID LPAREN arg_list RPAREN
    (76) anonymous_fun -> . LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (57) comp_op -> . expr EQUAL EQUAL expr
    (58) comp_op -> . expr BANG EQUAL expr
    (59) comp_op -> . expr GT expr
    (60) comp_op -> . expr GT EQUAL expr
    (61) comp_op -> . expr LT expr
    (62) comp_op -> . expr LT EQUAL expr
    (64) log_op -> . expr AND expr
    (65) log_op -> . expr OR expr
    (66) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 25
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 27
    MAC             shift and go to state 29
    ATOM            shift and go to state 30
    WHILE           shift and go to state 31
    FUN             shift and go to state 32
    NOT             shift and go to state 33

    expr                           shift and go to state 8
    statement_list                 shift and go to state 166
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    anonymous_fun                  shift and go to state 24
    comp_op                        shift and go to state 26
    log_op                         shift and go to state 28

state 166

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list . RBRACE conditional_elif

    RBRACE          shift and go to state 167


state 167

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE . conditional_elif
    (20) conditional_elif -> . ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif
    (21) conditional_elif -> . empty
    (3) empty -> .

    ELIF            shift and go to state 153
    ELSE            reduce using rule 3 (empty -> .)
    IMPORT          reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    NUMBER          reduce using rule 3 (empty -> .)
    BOOL            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    LBRACKET        reduce using rule 3 (empty -> .)
    LBRACE          reduce using rule 3 (empty -> .)
    PLACEHOLDER     reduce using rule 3 (empty -> .)
    MAC             reduce using rule 3 (empty -> .)
    ATOM            reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FUN             reduce using rule 3 (empty -> .)
    NOT             reduce using rule 3 (empty -> .)
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)

    conditional_elif               shift and go to state 168
    empty                          shift and go to state 154

state 168

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .

    ELSE            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    IMPORT          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    RETURN          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    IF              reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    STRING          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    NUMBER          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    BOOL            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    NULL            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    ID              reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    LPAREN          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    LBRACKET        reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    LBRACE          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    PLACEHOLDER     reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    MAC             reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    ATOM            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    WHILE           reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    FUN             reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    NOT             reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    $end            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    RPAREN          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    RBRACE          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 23 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 27 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 50 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 57 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 77 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 77 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 77 resolved as shift
WARNING: shift/reduce conflict for BANG in state 77 resolved as shift
WARNING: shift/reduce conflict for GT in state 77 resolved as shift
WARNING: shift/reduce conflict for LT in state 77 resolved as shift
WARNING: shift/reduce conflict for AND in state 77 resolved as shift
WARNING: shift/reduce conflict for OR in state 77 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 86 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for BANG in state 86 resolved as shift
WARNING: shift/reduce conflict for GT in state 86 resolved as shift
WARNING: shift/reduce conflict for LT in state 86 resolved as shift
WARNING: shift/reduce conflict for AND in state 86 resolved as shift
WARNING: shift/reduce conflict for OR in state 86 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 88 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 88 resolved as shift
WARNING: shift/reduce conflict for BANG in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for AND in state 88 resolved as shift
WARNING: shift/reduce conflict for OR in state 88 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 90 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 90 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 90 resolved as shift
WARNING: shift/reduce conflict for BANG in state 90 resolved as shift
WARNING: shift/reduce conflict for GT in state 90 resolved as shift
WARNING: shift/reduce conflict for LT in state 90 resolved as shift
WARNING: shift/reduce conflict for AND in state 90 resolved as shift
WARNING: shift/reduce conflict for OR in state 90 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 91 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 91 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 91 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 91 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 91 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 91 resolved as shift
WARNING: shift/reduce conflict for BANG in state 91 resolved as shift
WARNING: shift/reduce conflict for GT in state 91 resolved as shift
WARNING: shift/reduce conflict for LT in state 91 resolved as shift
WARNING: shift/reduce conflict for AND in state 91 resolved as shift
WARNING: shift/reduce conflict for OR in state 91 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for BANG in state 118 resolved as shift
WARNING: shift/reduce conflict for GT in state 118 resolved as shift
WARNING: shift/reduce conflict for LT in state 118 resolved as shift
WARNING: shift/reduce conflict for AND in state 118 resolved as shift
WARNING: shift/reduce conflict for OR in state 118 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 119 resolved as shift
WARNING: shift/reduce conflict for BANG in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 120 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for BANG in state 120 resolved as shift
WARNING: shift/reduce conflict for GT in state 120 resolved as shift
WARNING: shift/reduce conflict for LT in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for BANG in state 121 resolved as shift
WARNING: shift/reduce conflict for GT in state 121 resolved as shift
WARNING: shift/reduce conflict for LT in state 121 resolved as shift
WARNING: shift/reduce conflict for AND in state 121 resolved as shift
WARNING: shift/reduce conflict for OR in state 121 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 134 resolved as shift
WARNING: reduce/reduce conflict in state 23 resolved using rule (l_value -> ID)
WARNING: rejected rule (expr -> ID) in state 23
WARNING: reduce/reduce conflict in state 27 resolved using rule (l_value -> PLACEHOLDER)
WARNING: rejected rule (expr -> PLACEHOLDER) in state 27
WARNING: reduce/reduce conflict in state 57 resolved using rule (id_list -> ID)
WARNING: rejected rule (expr -> ID) in state 57
WARNING: reduce/reduce conflict in state 57 resolved using rule (l_value -> ID)
WARNING: rejected rule (expr -> ID) in state 57
WARNING: reduce/reduce conflict in state 58 resolved using rule (statement_list -> empty)
WARNING: rejected rule (id_list -> empty) in state 58
