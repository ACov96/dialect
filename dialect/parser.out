Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    END
    EXIT

Grammar

Rule 0     S' -> statement_list
Rule 1     statement_list -> statement statement_list
Rule 2     statement_list -> empty
Rule 3     empty -> <empty>
Rule 4     statement -> IMPORT STRING SEMICOLON
Rule 5     statement -> assignment SEMICOLON
Rule 6     statement -> conditional
Rule 7     statement -> expr SEMICOLON
Rule 8     statement -> macro_def
Rule 9     statement -> macro_call
Rule 10    assignment -> l_value EQUAL r_value
Rule 11    statement -> loop
Rule 12    loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
Rule 13    statement -> fun_def
Rule 14    fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
Rule 15    statement -> RETURN expr SEMICOLON
Rule 16    id_list -> ID
Rule 17    id_list -> ID COMMA id_list
Rule 18    id_list -> empty
Rule 19    conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
Rule 20    conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif
Rule 21    conditional_elif -> empty
Rule 22    conditional_else -> ELSE LBRACE statement_list RBRACE
Rule 23    conditional_else -> empty
Rule 24    r_value -> expr
Rule 25    l_value -> ID
Rule 26    l_value -> ID fields
Rule 27    l_value -> PLACEHOLDER
Rule 28    l_value -> PLACEHOLDER fields
Rule 29    fields -> LBRACKET expr RBRACKET
Rule 30    fields -> LBRACKET expr RBRACKET fields
Rule 31    expr -> alg_op
Rule 32    expr -> STRING
Rule 33    expr -> NUMBER
Rule 34    expr -> BOOL
Rule 35    expr -> NULL
Rule 36    expr -> func_call
Rule 37    expr -> ID
Rule 38    expr -> LPAREN expr RPAREN
Rule 39    func_call -> ID LPAREN arg_list RPAREN
Rule 40    arg_list -> empty
Rule 41    arg_list -> expr
Rule 42    arg_list -> expr COMMA arg_list
Rule 43    alg_op -> expr PLUS expr
Rule 44    alg_op -> expr MINUS expr
Rule 45    alg_op -> expr MULTIPLY expr
Rule 46    alg_op -> expr DIVIDE expr
Rule 47    expr -> LBRACKET arg_list RBRACKET
Rule 48    expr -> LBRACE record_list RBRACE
Rule 49    expr -> LPAREN statement_list RPAREN
Rule 50    record_list -> ID COLON expr
Rule 51    record_list -> ID COLON expr COMMA record_list
Rule 52    record_list -> empty
Rule 53    expr -> expr LBRACKET expr RBRACKET
Rule 54    expr -> comp_op
Rule 55    expr -> PLACEHOLDER
Rule 56    comp_op -> expr EQUAL EQUAL expr
Rule 57    comp_op -> expr BANG EQUAL expr
Rule 58    comp_op -> expr GT expr
Rule 59    comp_op -> expr GT EQUAL expr
Rule 60    comp_op -> expr LT expr
Rule 61    comp_op -> expr LT EQUAL expr
Rule 62    expr -> log_op
Rule 63    log_op -> expr AND expr
Rule 64    log_op -> expr OR expr
Rule 65    log_op -> NOT expr
Rule 66    macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE
Rule 67    macro_def_arg_list -> ATOM macro_def_arg_list_rec
Rule 68    macro_def_arg_list_rec -> PLACEHOLDER macro_def_arg_list_rec
Rule 69    macro_def_arg_list_rec -> ATOM macro_def_arg_list_rec
Rule 70    macro_def_arg_list_rec -> empty
Rule 71    macro_call -> ATOM macro_arg_list SEMICOLON
Rule 72    macro_arg_list -> ATOM macro_arg_list
Rule 73    macro_arg_list -> expr macro_arg_list
Rule 74    macro_arg_list -> empty

Terminals, with rules where they appear

AND                  : 63
ATOM                 : 67 69 71 72
BANG                 : 57
BOOL                 : 34
COLON                : 50 51
COMMA                : 17 42 51
DIVIDE               : 46
ELIF                 : 20
ELSE                 : 22
END                  : 
EQUAL                : 10 56 56 57 59 61
EXIT                 : 
FUN                  : 14
GT                   : 58 59
ID                   : 14 16 17 25 26 37 39 50 51
IF                   : 19
IMPORT               : 4
LBRACE               : 12 14 19 20 22 48 66
LBRACKET             : 29 30 47 53
LPAREN               : 12 14 19 20 38 39 49
LT                   : 60 61
MAC                  : 66
MINUS                : 44
MULTIPLY             : 45
NOT                  : 65
NULL                 : 35
NUMBER               : 33
OR                   : 64
PLACEHOLDER          : 27 28 55 68
PLUS                 : 43
RBRACE               : 12 14 19 20 22 48 66
RBRACKET             : 29 30 47 53
RETURN               : 15
RPAREN               : 12 14 19 20 38 39 49
SEMICOLON            : 4 5 7 15 71
STRING               : 4 32
WHILE                : 12
error                : 

Nonterminals, with rules where they appear

alg_op               : 31
arg_list             : 39 42 47
assignment           : 5
comp_op              : 54
conditional          : 6
conditional_elif     : 19 20
conditional_else     : 19
empty                : 2 18 21 23 40 52 70 74
expr                 : 7 12 15 19 20 24 29 30 38 41 42 43 43 44 44 45 45 46 46 50 51 53 53 56 56 57 57 58 58 59 59 60 60 61 61 63 63 64 64 65 73
fields               : 26 28 30
fun_def              : 13
func_call            : 36
id_list              : 14 17
l_value              : 10
log_op               : 62
loop                 : 11
macro_arg_list       : 71 72 73
macro_call           : 9
macro_def            : 8
macro_def_arg_list   : 66
macro_def_arg_list_rec : 67 68 69
r_value              : 10
record_list          : 48 51
statement            : 1
statement_list       : 1 12 14 19 20 22 49 66 0

Parsing method: LALR

state 0

    (0) S' -> . statement_list
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    $end            reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    statement_list                 shift and go to state 1
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 1

    (0) S' -> statement_list .



state 2

    (1) statement_list -> statement . statement_list
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    statement                      shift and go to state 2
    statement_list                 shift and go to state 33
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 3

    (2) statement_list -> empty .

    $end            reduce using rule 2 (statement_list -> empty .)
    RPAREN          reduce using rule 2 (statement_list -> empty .)
    RBRACE          reduce using rule 2 (statement_list -> empty .)


state 4

    (4) statement -> IMPORT . STRING SEMICOLON

    STRING          shift and go to state 34


state 5

    (32) expr -> STRING .

    SEMICOLON       reduce using rule 32 (expr -> STRING .)
    LBRACKET        reduce using rule 32 (expr -> STRING .)
    PLUS            reduce using rule 32 (expr -> STRING .)
    MINUS           reduce using rule 32 (expr -> STRING .)
    MULTIPLY        reduce using rule 32 (expr -> STRING .)
    DIVIDE          reduce using rule 32 (expr -> STRING .)
    EQUAL           reduce using rule 32 (expr -> STRING .)
    BANG            reduce using rule 32 (expr -> STRING .)
    GT              reduce using rule 32 (expr -> STRING .)
    LT              reduce using rule 32 (expr -> STRING .)
    AND             reduce using rule 32 (expr -> STRING .)
    OR              reduce using rule 32 (expr -> STRING .)
    RPAREN          reduce using rule 32 (expr -> STRING .)
    COMMA           reduce using rule 32 (expr -> STRING .)
    RBRACKET        reduce using rule 32 (expr -> STRING .)
    ATOM            reduce using rule 32 (expr -> STRING .)
    STRING          reduce using rule 32 (expr -> STRING .)
    NUMBER          reduce using rule 32 (expr -> STRING .)
    BOOL            reduce using rule 32 (expr -> STRING .)
    NULL            reduce using rule 32 (expr -> STRING .)
    ID              reduce using rule 32 (expr -> STRING .)
    LPAREN          reduce using rule 32 (expr -> STRING .)
    LBRACE          reduce using rule 32 (expr -> STRING .)
    PLACEHOLDER     reduce using rule 32 (expr -> STRING .)
    NOT             reduce using rule 32 (expr -> STRING .)
    RBRACE          reduce using rule 32 (expr -> STRING .)


state 6

    (5) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 35


state 7

    (6) statement -> conditional .

    IMPORT          reduce using rule 6 (statement -> conditional .)
    RETURN          reduce using rule 6 (statement -> conditional .)
    IF              reduce using rule 6 (statement -> conditional .)
    STRING          reduce using rule 6 (statement -> conditional .)
    NUMBER          reduce using rule 6 (statement -> conditional .)
    BOOL            reduce using rule 6 (statement -> conditional .)
    NULL            reduce using rule 6 (statement -> conditional .)
    ID              reduce using rule 6 (statement -> conditional .)
    LPAREN          reduce using rule 6 (statement -> conditional .)
    LBRACKET        reduce using rule 6 (statement -> conditional .)
    LBRACE          reduce using rule 6 (statement -> conditional .)
    PLACEHOLDER     reduce using rule 6 (statement -> conditional .)
    MAC             reduce using rule 6 (statement -> conditional .)
    ATOM            reduce using rule 6 (statement -> conditional .)
    WHILE           reduce using rule 6 (statement -> conditional .)
    FUN             reduce using rule 6 (statement -> conditional .)
    NOT             reduce using rule 6 (statement -> conditional .)
    $end            reduce using rule 6 (statement -> conditional .)
    RPAREN          reduce using rule 6 (statement -> conditional .)
    RBRACE          reduce using rule 6 (statement -> conditional .)


state 8

    (7) statement -> expr . SEMICOLON
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       shift and go to state 36
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 9

    (8) statement -> macro_def .

    IMPORT          reduce using rule 8 (statement -> macro_def .)
    RETURN          reduce using rule 8 (statement -> macro_def .)
    IF              reduce using rule 8 (statement -> macro_def .)
    STRING          reduce using rule 8 (statement -> macro_def .)
    NUMBER          reduce using rule 8 (statement -> macro_def .)
    BOOL            reduce using rule 8 (statement -> macro_def .)
    NULL            reduce using rule 8 (statement -> macro_def .)
    ID              reduce using rule 8 (statement -> macro_def .)
    LPAREN          reduce using rule 8 (statement -> macro_def .)
    LBRACKET        reduce using rule 8 (statement -> macro_def .)
    LBRACE          reduce using rule 8 (statement -> macro_def .)
    PLACEHOLDER     reduce using rule 8 (statement -> macro_def .)
    MAC             reduce using rule 8 (statement -> macro_def .)
    ATOM            reduce using rule 8 (statement -> macro_def .)
    WHILE           reduce using rule 8 (statement -> macro_def .)
    FUN             reduce using rule 8 (statement -> macro_def .)
    NOT             reduce using rule 8 (statement -> macro_def .)
    $end            reduce using rule 8 (statement -> macro_def .)
    RPAREN          reduce using rule 8 (statement -> macro_def .)
    RBRACE          reduce using rule 8 (statement -> macro_def .)


state 10

    (9) statement -> macro_call .

    IMPORT          reduce using rule 9 (statement -> macro_call .)
    RETURN          reduce using rule 9 (statement -> macro_call .)
    IF              reduce using rule 9 (statement -> macro_call .)
    STRING          reduce using rule 9 (statement -> macro_call .)
    NUMBER          reduce using rule 9 (statement -> macro_call .)
    BOOL            reduce using rule 9 (statement -> macro_call .)
    NULL            reduce using rule 9 (statement -> macro_call .)
    ID              reduce using rule 9 (statement -> macro_call .)
    LPAREN          reduce using rule 9 (statement -> macro_call .)
    LBRACKET        reduce using rule 9 (statement -> macro_call .)
    LBRACE          reduce using rule 9 (statement -> macro_call .)
    PLACEHOLDER     reduce using rule 9 (statement -> macro_call .)
    MAC             reduce using rule 9 (statement -> macro_call .)
    ATOM            reduce using rule 9 (statement -> macro_call .)
    WHILE           reduce using rule 9 (statement -> macro_call .)
    FUN             reduce using rule 9 (statement -> macro_call .)
    NOT             reduce using rule 9 (statement -> macro_call .)
    $end            reduce using rule 9 (statement -> macro_call .)
    RPAREN          reduce using rule 9 (statement -> macro_call .)
    RBRACE          reduce using rule 9 (statement -> macro_call .)


state 11

    (11) statement -> loop .

    IMPORT          reduce using rule 11 (statement -> loop .)
    RETURN          reduce using rule 11 (statement -> loop .)
    IF              reduce using rule 11 (statement -> loop .)
    STRING          reduce using rule 11 (statement -> loop .)
    NUMBER          reduce using rule 11 (statement -> loop .)
    BOOL            reduce using rule 11 (statement -> loop .)
    NULL            reduce using rule 11 (statement -> loop .)
    ID              reduce using rule 11 (statement -> loop .)
    LPAREN          reduce using rule 11 (statement -> loop .)
    LBRACKET        reduce using rule 11 (statement -> loop .)
    LBRACE          reduce using rule 11 (statement -> loop .)
    PLACEHOLDER     reduce using rule 11 (statement -> loop .)
    MAC             reduce using rule 11 (statement -> loop .)
    ATOM            reduce using rule 11 (statement -> loop .)
    WHILE           reduce using rule 11 (statement -> loop .)
    FUN             reduce using rule 11 (statement -> loop .)
    NOT             reduce using rule 11 (statement -> loop .)
    $end            reduce using rule 11 (statement -> loop .)
    RPAREN          reduce using rule 11 (statement -> loop .)
    RBRACE          reduce using rule 11 (statement -> loop .)


state 12

    (13) statement -> fun_def .

    IMPORT          reduce using rule 13 (statement -> fun_def .)
    RETURN          reduce using rule 13 (statement -> fun_def .)
    IF              reduce using rule 13 (statement -> fun_def .)
    STRING          reduce using rule 13 (statement -> fun_def .)
    NUMBER          reduce using rule 13 (statement -> fun_def .)
    BOOL            reduce using rule 13 (statement -> fun_def .)
    NULL            reduce using rule 13 (statement -> fun_def .)
    ID              reduce using rule 13 (statement -> fun_def .)
    LPAREN          reduce using rule 13 (statement -> fun_def .)
    LBRACKET        reduce using rule 13 (statement -> fun_def .)
    LBRACE          reduce using rule 13 (statement -> fun_def .)
    PLACEHOLDER     reduce using rule 13 (statement -> fun_def .)
    MAC             reduce using rule 13 (statement -> fun_def .)
    ATOM            reduce using rule 13 (statement -> fun_def .)
    WHILE           reduce using rule 13 (statement -> fun_def .)
    FUN             reduce using rule 13 (statement -> fun_def .)
    NOT             reduce using rule 13 (statement -> fun_def .)
    $end            reduce using rule 13 (statement -> fun_def .)
    RPAREN          reduce using rule 13 (statement -> fun_def .)
    RBRACE          reduce using rule 13 (statement -> fun_def .)


state 13

    (15) statement -> RETURN . expr SEMICOLON
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 48
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 14

    (10) assignment -> l_value . EQUAL r_value

    EQUAL           shift and go to state 51


state 15

    (19) conditional -> IF . LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else

    LPAREN          shift and go to state 52


state 16

    (38) expr -> LPAREN . expr RPAREN
    (49) expr -> LPAREN . statement_list RPAREN
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 55
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    NOT             shift and go to state 32
    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RPAREN          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31

    expr                           shift and go to state 53
    statement_list                 shift and go to state 54
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14

state 17

    (48) expr -> LBRACE . record_list RBRACE
    (50) record_list -> . ID COLON expr
    (51) record_list -> . ID COLON expr COMMA record_list
    (52) record_list -> . empty
    (3) empty -> .

    ID              shift and go to state 57
    RBRACE          reduce using rule 3 (empty -> .)

    record_list                    shift and go to state 56
    empty                          shift and go to state 58

state 18

    (31) expr -> alg_op .

    SEMICOLON       reduce using rule 31 (expr -> alg_op .)
    LBRACKET        reduce using rule 31 (expr -> alg_op .)
    PLUS            reduce using rule 31 (expr -> alg_op .)
    MINUS           reduce using rule 31 (expr -> alg_op .)
    MULTIPLY        reduce using rule 31 (expr -> alg_op .)
    DIVIDE          reduce using rule 31 (expr -> alg_op .)
    EQUAL           reduce using rule 31 (expr -> alg_op .)
    BANG            reduce using rule 31 (expr -> alg_op .)
    GT              reduce using rule 31 (expr -> alg_op .)
    LT              reduce using rule 31 (expr -> alg_op .)
    AND             reduce using rule 31 (expr -> alg_op .)
    OR              reduce using rule 31 (expr -> alg_op .)
    RPAREN          reduce using rule 31 (expr -> alg_op .)
    COMMA           reduce using rule 31 (expr -> alg_op .)
    RBRACKET        reduce using rule 31 (expr -> alg_op .)
    ATOM            reduce using rule 31 (expr -> alg_op .)
    STRING          reduce using rule 31 (expr -> alg_op .)
    NUMBER          reduce using rule 31 (expr -> alg_op .)
    BOOL            reduce using rule 31 (expr -> alg_op .)
    NULL            reduce using rule 31 (expr -> alg_op .)
    ID              reduce using rule 31 (expr -> alg_op .)
    LPAREN          reduce using rule 31 (expr -> alg_op .)
    LBRACE          reduce using rule 31 (expr -> alg_op .)
    PLACEHOLDER     reduce using rule 31 (expr -> alg_op .)
    NOT             reduce using rule 31 (expr -> alg_op .)
    RBRACE          reduce using rule 31 (expr -> alg_op .)


state 19

    (33) expr -> NUMBER .

    SEMICOLON       reduce using rule 33 (expr -> NUMBER .)
    LBRACKET        reduce using rule 33 (expr -> NUMBER .)
    PLUS            reduce using rule 33 (expr -> NUMBER .)
    MINUS           reduce using rule 33 (expr -> NUMBER .)
    MULTIPLY        reduce using rule 33 (expr -> NUMBER .)
    DIVIDE          reduce using rule 33 (expr -> NUMBER .)
    EQUAL           reduce using rule 33 (expr -> NUMBER .)
    BANG            reduce using rule 33 (expr -> NUMBER .)
    GT              reduce using rule 33 (expr -> NUMBER .)
    LT              reduce using rule 33 (expr -> NUMBER .)
    AND             reduce using rule 33 (expr -> NUMBER .)
    OR              reduce using rule 33 (expr -> NUMBER .)
    RPAREN          reduce using rule 33 (expr -> NUMBER .)
    COMMA           reduce using rule 33 (expr -> NUMBER .)
    RBRACKET        reduce using rule 33 (expr -> NUMBER .)
    ATOM            reduce using rule 33 (expr -> NUMBER .)
    STRING          reduce using rule 33 (expr -> NUMBER .)
    NUMBER          reduce using rule 33 (expr -> NUMBER .)
    BOOL            reduce using rule 33 (expr -> NUMBER .)
    NULL            reduce using rule 33 (expr -> NUMBER .)
    ID              reduce using rule 33 (expr -> NUMBER .)
    LPAREN          reduce using rule 33 (expr -> NUMBER .)
    LBRACE          reduce using rule 33 (expr -> NUMBER .)
    PLACEHOLDER     reduce using rule 33 (expr -> NUMBER .)
    NOT             reduce using rule 33 (expr -> NUMBER .)
    RBRACE          reduce using rule 33 (expr -> NUMBER .)


state 20

    (34) expr -> BOOL .

    SEMICOLON       reduce using rule 34 (expr -> BOOL .)
    LBRACKET        reduce using rule 34 (expr -> BOOL .)
    PLUS            reduce using rule 34 (expr -> BOOL .)
    MINUS           reduce using rule 34 (expr -> BOOL .)
    MULTIPLY        reduce using rule 34 (expr -> BOOL .)
    DIVIDE          reduce using rule 34 (expr -> BOOL .)
    EQUAL           reduce using rule 34 (expr -> BOOL .)
    BANG            reduce using rule 34 (expr -> BOOL .)
    GT              reduce using rule 34 (expr -> BOOL .)
    LT              reduce using rule 34 (expr -> BOOL .)
    AND             reduce using rule 34 (expr -> BOOL .)
    OR              reduce using rule 34 (expr -> BOOL .)
    RPAREN          reduce using rule 34 (expr -> BOOL .)
    COMMA           reduce using rule 34 (expr -> BOOL .)
    RBRACKET        reduce using rule 34 (expr -> BOOL .)
    ATOM            reduce using rule 34 (expr -> BOOL .)
    STRING          reduce using rule 34 (expr -> BOOL .)
    NUMBER          reduce using rule 34 (expr -> BOOL .)
    BOOL            reduce using rule 34 (expr -> BOOL .)
    NULL            reduce using rule 34 (expr -> BOOL .)
    ID              reduce using rule 34 (expr -> BOOL .)
    LPAREN          reduce using rule 34 (expr -> BOOL .)
    LBRACE          reduce using rule 34 (expr -> BOOL .)
    PLACEHOLDER     reduce using rule 34 (expr -> BOOL .)
    NOT             reduce using rule 34 (expr -> BOOL .)
    RBRACE          reduce using rule 34 (expr -> BOOL .)


state 21

    (35) expr -> NULL .

    SEMICOLON       reduce using rule 35 (expr -> NULL .)
    LBRACKET        reduce using rule 35 (expr -> NULL .)
    PLUS            reduce using rule 35 (expr -> NULL .)
    MINUS           reduce using rule 35 (expr -> NULL .)
    MULTIPLY        reduce using rule 35 (expr -> NULL .)
    DIVIDE          reduce using rule 35 (expr -> NULL .)
    EQUAL           reduce using rule 35 (expr -> NULL .)
    BANG            reduce using rule 35 (expr -> NULL .)
    GT              reduce using rule 35 (expr -> NULL .)
    LT              reduce using rule 35 (expr -> NULL .)
    AND             reduce using rule 35 (expr -> NULL .)
    OR              reduce using rule 35 (expr -> NULL .)
    RPAREN          reduce using rule 35 (expr -> NULL .)
    COMMA           reduce using rule 35 (expr -> NULL .)
    RBRACKET        reduce using rule 35 (expr -> NULL .)
    ATOM            reduce using rule 35 (expr -> NULL .)
    STRING          reduce using rule 35 (expr -> NULL .)
    NUMBER          reduce using rule 35 (expr -> NULL .)
    BOOL            reduce using rule 35 (expr -> NULL .)
    NULL            reduce using rule 35 (expr -> NULL .)
    ID              reduce using rule 35 (expr -> NULL .)
    LPAREN          reduce using rule 35 (expr -> NULL .)
    LBRACE          reduce using rule 35 (expr -> NULL .)
    PLACEHOLDER     reduce using rule 35 (expr -> NULL .)
    NOT             reduce using rule 35 (expr -> NULL .)
    RBRACE          reduce using rule 35 (expr -> NULL .)


state 22

    (36) expr -> func_call .

    SEMICOLON       reduce using rule 36 (expr -> func_call .)
    LBRACKET        reduce using rule 36 (expr -> func_call .)
    PLUS            reduce using rule 36 (expr -> func_call .)
    MINUS           reduce using rule 36 (expr -> func_call .)
    MULTIPLY        reduce using rule 36 (expr -> func_call .)
    DIVIDE          reduce using rule 36 (expr -> func_call .)
    EQUAL           reduce using rule 36 (expr -> func_call .)
    BANG            reduce using rule 36 (expr -> func_call .)
    GT              reduce using rule 36 (expr -> func_call .)
    LT              reduce using rule 36 (expr -> func_call .)
    AND             reduce using rule 36 (expr -> func_call .)
    OR              reduce using rule 36 (expr -> func_call .)
    RPAREN          reduce using rule 36 (expr -> func_call .)
    COMMA           reduce using rule 36 (expr -> func_call .)
    RBRACKET        reduce using rule 36 (expr -> func_call .)
    ATOM            reduce using rule 36 (expr -> func_call .)
    STRING          reduce using rule 36 (expr -> func_call .)
    NUMBER          reduce using rule 36 (expr -> func_call .)
    BOOL            reduce using rule 36 (expr -> func_call .)
    NULL            reduce using rule 36 (expr -> func_call .)
    ID              reduce using rule 36 (expr -> func_call .)
    LPAREN          reduce using rule 36 (expr -> func_call .)
    LBRACE          reduce using rule 36 (expr -> func_call .)
    PLACEHOLDER     reduce using rule 36 (expr -> func_call .)
    NOT             reduce using rule 36 (expr -> func_call .)
    RBRACE          reduce using rule 36 (expr -> func_call .)


state 23

    (37) expr -> ID .
    (25) l_value -> ID .
    (26) l_value -> ID . fields
    (39) func_call -> ID . LPAREN arg_list RPAREN
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

  ! reduce/reduce conflict for EQUAL resolved using rule 25 (l_value -> ID .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMICOLON       reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    MULTIPLY        reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    BANG            reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    AND             reduce using rule 37 (expr -> ID .)
    OR              reduce using rule 37 (expr -> ID .)
    EQUAL           reduce using rule 25 (l_value -> ID .)
    LPAREN          shift and go to state 60
    LBRACKET        shift and go to state 61

  ! LBRACKET        [ reduce using rule 37 (expr -> ID .) ]
  ! EQUAL           [ reduce using rule 37 (expr -> ID .) ]

    fields                         shift and go to state 59

state 24

    (47) expr -> LBRACKET . arg_list RBRACKET
    (40) arg_list -> . empty
    (41) arg_list -> . expr
    (42) arg_list -> . expr COMMA arg_list
    (3) empty -> .
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    RBRACKET        reduce using rule 3 (empty -> .)
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    arg_list                       shift and go to state 62
    empty                          shift and go to state 63
    expr                           shift and go to state 64
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 25

    (54) expr -> comp_op .

    SEMICOLON       reduce using rule 54 (expr -> comp_op .)
    LBRACKET        reduce using rule 54 (expr -> comp_op .)
    PLUS            reduce using rule 54 (expr -> comp_op .)
    MINUS           reduce using rule 54 (expr -> comp_op .)
    MULTIPLY        reduce using rule 54 (expr -> comp_op .)
    DIVIDE          reduce using rule 54 (expr -> comp_op .)
    EQUAL           reduce using rule 54 (expr -> comp_op .)
    BANG            reduce using rule 54 (expr -> comp_op .)
    GT              reduce using rule 54 (expr -> comp_op .)
    LT              reduce using rule 54 (expr -> comp_op .)
    AND             reduce using rule 54 (expr -> comp_op .)
    OR              reduce using rule 54 (expr -> comp_op .)
    RPAREN          reduce using rule 54 (expr -> comp_op .)
    COMMA           reduce using rule 54 (expr -> comp_op .)
    RBRACKET        reduce using rule 54 (expr -> comp_op .)
    ATOM            reduce using rule 54 (expr -> comp_op .)
    STRING          reduce using rule 54 (expr -> comp_op .)
    NUMBER          reduce using rule 54 (expr -> comp_op .)
    BOOL            reduce using rule 54 (expr -> comp_op .)
    NULL            reduce using rule 54 (expr -> comp_op .)
    ID              reduce using rule 54 (expr -> comp_op .)
    LPAREN          reduce using rule 54 (expr -> comp_op .)
    LBRACE          reduce using rule 54 (expr -> comp_op .)
    PLACEHOLDER     reduce using rule 54 (expr -> comp_op .)
    NOT             reduce using rule 54 (expr -> comp_op .)
    RBRACE          reduce using rule 54 (expr -> comp_op .)


state 26

    (55) expr -> PLACEHOLDER .
    (27) l_value -> PLACEHOLDER .
    (28) l_value -> PLACEHOLDER . fields
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

  ! reduce/reduce conflict for EQUAL resolved using rule 27 (l_value -> PLACEHOLDER .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMICOLON       reduce using rule 55 (expr -> PLACEHOLDER .)
    PLUS            reduce using rule 55 (expr -> PLACEHOLDER .)
    MINUS           reduce using rule 55 (expr -> PLACEHOLDER .)
    MULTIPLY        reduce using rule 55 (expr -> PLACEHOLDER .)
    DIVIDE          reduce using rule 55 (expr -> PLACEHOLDER .)
    BANG            reduce using rule 55 (expr -> PLACEHOLDER .)
    GT              reduce using rule 55 (expr -> PLACEHOLDER .)
    LT              reduce using rule 55 (expr -> PLACEHOLDER .)
    AND             reduce using rule 55 (expr -> PLACEHOLDER .)
    OR              reduce using rule 55 (expr -> PLACEHOLDER .)
    RPAREN          reduce using rule 55 (expr -> PLACEHOLDER .)
    EQUAL           reduce using rule 27 (l_value -> PLACEHOLDER .)
    LBRACKET        shift and go to state 61

  ! LBRACKET        [ reduce using rule 55 (expr -> PLACEHOLDER .) ]
  ! EQUAL           [ reduce using rule 55 (expr -> PLACEHOLDER .) ]

    fields                         shift and go to state 65

state 27

    (62) expr -> log_op .

    SEMICOLON       reduce using rule 62 (expr -> log_op .)
    LBRACKET        reduce using rule 62 (expr -> log_op .)
    PLUS            reduce using rule 62 (expr -> log_op .)
    MINUS           reduce using rule 62 (expr -> log_op .)
    MULTIPLY        reduce using rule 62 (expr -> log_op .)
    DIVIDE          reduce using rule 62 (expr -> log_op .)
    EQUAL           reduce using rule 62 (expr -> log_op .)
    BANG            reduce using rule 62 (expr -> log_op .)
    GT              reduce using rule 62 (expr -> log_op .)
    LT              reduce using rule 62 (expr -> log_op .)
    AND             reduce using rule 62 (expr -> log_op .)
    OR              reduce using rule 62 (expr -> log_op .)
    RPAREN          reduce using rule 62 (expr -> log_op .)
    COMMA           reduce using rule 62 (expr -> log_op .)
    RBRACKET        reduce using rule 62 (expr -> log_op .)
    ATOM            reduce using rule 62 (expr -> log_op .)
    STRING          reduce using rule 62 (expr -> log_op .)
    NUMBER          reduce using rule 62 (expr -> log_op .)
    BOOL            reduce using rule 62 (expr -> log_op .)
    NULL            reduce using rule 62 (expr -> log_op .)
    ID              reduce using rule 62 (expr -> log_op .)
    LPAREN          reduce using rule 62 (expr -> log_op .)
    LBRACE          reduce using rule 62 (expr -> log_op .)
    PLACEHOLDER     reduce using rule 62 (expr -> log_op .)
    NOT             reduce using rule 62 (expr -> log_op .)
    RBRACE          reduce using rule 62 (expr -> log_op .)


state 28

    (66) macro_def -> MAC . macro_def_arg_list LBRACE statement_list RBRACE
    (67) macro_def_arg_list -> . ATOM macro_def_arg_list_rec

    ATOM            shift and go to state 67

    macro_def_arg_list             shift and go to state 66

state 29

    (71) macro_call -> ATOM . macro_arg_list SEMICOLON
    (72) macro_arg_list -> . ATOM macro_arg_list
    (73) macro_arg_list -> . expr macro_arg_list
    (74) macro_arg_list -> . empty
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (3) empty -> .
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    ATOM            shift and go to state 68
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    SEMICOLON       reduce using rule 3 (empty -> .)
    NOT             shift and go to state 32

    macro_arg_list                 shift and go to state 69
    expr                           shift and go to state 70
    empty                          shift and go to state 71
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 30

    (12) loop -> WHILE . LPAREN expr RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 72


state 31

    (14) fun_def -> FUN . ID LPAREN id_list RPAREN LBRACE statement_list RBRACE

    ID              shift and go to state 73


state 32

    (65) log_op -> NOT . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 74
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 33

    (1) statement_list -> statement statement_list .

    $end            reduce using rule 1 (statement_list -> statement statement_list .)
    RPAREN          reduce using rule 1 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 1 (statement_list -> statement statement_list .)


state 34

    (4) statement -> IMPORT STRING . SEMICOLON

    SEMICOLON       shift and go to state 75


state 35

    (5) statement -> assignment SEMICOLON .

    IMPORT          reduce using rule 5 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 5 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 5 (statement -> assignment SEMICOLON .)
    STRING          reduce using rule 5 (statement -> assignment SEMICOLON .)
    NUMBER          reduce using rule 5 (statement -> assignment SEMICOLON .)
    BOOL            reduce using rule 5 (statement -> assignment SEMICOLON .)
    NULL            reduce using rule 5 (statement -> assignment SEMICOLON .)
    ID              reduce using rule 5 (statement -> assignment SEMICOLON .)
    LPAREN          reduce using rule 5 (statement -> assignment SEMICOLON .)
    LBRACKET        reduce using rule 5 (statement -> assignment SEMICOLON .)
    LBRACE          reduce using rule 5 (statement -> assignment SEMICOLON .)
    PLACEHOLDER     reduce using rule 5 (statement -> assignment SEMICOLON .)
    MAC             reduce using rule 5 (statement -> assignment SEMICOLON .)
    ATOM            reduce using rule 5 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 5 (statement -> assignment SEMICOLON .)
    FUN             reduce using rule 5 (statement -> assignment SEMICOLON .)
    NOT             reduce using rule 5 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 5 (statement -> assignment SEMICOLON .)
    RPAREN          reduce using rule 5 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 5 (statement -> assignment SEMICOLON .)


state 36

    (7) statement -> expr SEMICOLON .

    IMPORT          reduce using rule 7 (statement -> expr SEMICOLON .)
    RETURN          reduce using rule 7 (statement -> expr SEMICOLON .)
    IF              reduce using rule 7 (statement -> expr SEMICOLON .)
    STRING          reduce using rule 7 (statement -> expr SEMICOLON .)
    NUMBER          reduce using rule 7 (statement -> expr SEMICOLON .)
    BOOL            reduce using rule 7 (statement -> expr SEMICOLON .)
    NULL            reduce using rule 7 (statement -> expr SEMICOLON .)
    ID              reduce using rule 7 (statement -> expr SEMICOLON .)
    LPAREN          reduce using rule 7 (statement -> expr SEMICOLON .)
    LBRACKET        reduce using rule 7 (statement -> expr SEMICOLON .)
    LBRACE          reduce using rule 7 (statement -> expr SEMICOLON .)
    PLACEHOLDER     reduce using rule 7 (statement -> expr SEMICOLON .)
    MAC             reduce using rule 7 (statement -> expr SEMICOLON .)
    ATOM            reduce using rule 7 (statement -> expr SEMICOLON .)
    WHILE           reduce using rule 7 (statement -> expr SEMICOLON .)
    FUN             reduce using rule 7 (statement -> expr SEMICOLON .)
    NOT             reduce using rule 7 (statement -> expr SEMICOLON .)
    $end            reduce using rule 7 (statement -> expr SEMICOLON .)
    RPAREN          reduce using rule 7 (statement -> expr SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> expr SEMICOLON .)


state 37

    (53) expr -> expr LBRACKET . expr RBRACKET
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 76
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 38

    (43) alg_op -> expr PLUS . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 77
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 39

    (44) alg_op -> expr MINUS . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 78
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 40

    (45) alg_op -> expr MULTIPLY . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 79
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 41

    (46) alg_op -> expr DIVIDE . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 80
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 42

    (56) comp_op -> expr EQUAL . EQUAL expr

    EQUAL           shift and go to state 81


state 43

    (57) comp_op -> expr BANG . EQUAL expr

    EQUAL           shift and go to state 82


state 44

    (58) comp_op -> expr GT . expr
    (59) comp_op -> expr GT . EQUAL expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    EQUAL           shift and go to state 84
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 83
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 45

    (60) comp_op -> expr LT . expr
    (61) comp_op -> expr LT . EQUAL expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    EQUAL           shift and go to state 86
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 85
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 46

    (63) log_op -> expr AND . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 87
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 47

    (64) log_op -> expr OR . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 88
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 48

    (15) statement -> RETURN expr . SEMICOLON
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       shift and go to state 89
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 49

    (37) expr -> ID .
    (39) func_call -> ID . LPAREN arg_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    SEMICOLON       reduce using rule 37 (expr -> ID .)
    LBRACKET        reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    MULTIPLY        reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    EQUAL           reduce using rule 37 (expr -> ID .)
    BANG            reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    AND             reduce using rule 37 (expr -> ID .)
    OR              reduce using rule 37 (expr -> ID .)
    COMMA           reduce using rule 37 (expr -> ID .)
    RBRACKET        reduce using rule 37 (expr -> ID .)
    ATOM            reduce using rule 37 (expr -> ID .)
    STRING          reduce using rule 37 (expr -> ID .)
    NUMBER          reduce using rule 37 (expr -> ID .)
    BOOL            reduce using rule 37 (expr -> ID .)
    NULL            reduce using rule 37 (expr -> ID .)
    ID              reduce using rule 37 (expr -> ID .)
    LBRACE          reduce using rule 37 (expr -> ID .)
    PLACEHOLDER     reduce using rule 37 (expr -> ID .)
    NOT             reduce using rule 37 (expr -> ID .)
    RPAREN          reduce using rule 37 (expr -> ID .)
    RBRACE          reduce using rule 37 (expr -> ID .)
    LPAREN          shift and go to state 60

  ! LPAREN          [ reduce using rule 37 (expr -> ID .) ]


state 50

    (55) expr -> PLACEHOLDER .

    SEMICOLON       reduce using rule 55 (expr -> PLACEHOLDER .)
    LBRACKET        reduce using rule 55 (expr -> PLACEHOLDER .)
    PLUS            reduce using rule 55 (expr -> PLACEHOLDER .)
    MINUS           reduce using rule 55 (expr -> PLACEHOLDER .)
    MULTIPLY        reduce using rule 55 (expr -> PLACEHOLDER .)
    DIVIDE          reduce using rule 55 (expr -> PLACEHOLDER .)
    EQUAL           reduce using rule 55 (expr -> PLACEHOLDER .)
    BANG            reduce using rule 55 (expr -> PLACEHOLDER .)
    GT              reduce using rule 55 (expr -> PLACEHOLDER .)
    LT              reduce using rule 55 (expr -> PLACEHOLDER .)
    AND             reduce using rule 55 (expr -> PLACEHOLDER .)
    OR              reduce using rule 55 (expr -> PLACEHOLDER .)
    COMMA           reduce using rule 55 (expr -> PLACEHOLDER .)
    RBRACKET        reduce using rule 55 (expr -> PLACEHOLDER .)
    ATOM            reduce using rule 55 (expr -> PLACEHOLDER .)
    STRING          reduce using rule 55 (expr -> PLACEHOLDER .)
    NUMBER          reduce using rule 55 (expr -> PLACEHOLDER .)
    BOOL            reduce using rule 55 (expr -> PLACEHOLDER .)
    NULL            reduce using rule 55 (expr -> PLACEHOLDER .)
    ID              reduce using rule 55 (expr -> PLACEHOLDER .)
    LPAREN          reduce using rule 55 (expr -> PLACEHOLDER .)
    LBRACE          reduce using rule 55 (expr -> PLACEHOLDER .)
    PLACEHOLDER     reduce using rule 55 (expr -> PLACEHOLDER .)
    NOT             reduce using rule 55 (expr -> PLACEHOLDER .)
    RPAREN          reduce using rule 55 (expr -> PLACEHOLDER .)
    RBRACE          reduce using rule 55 (expr -> PLACEHOLDER .)


state 51

    (10) assignment -> l_value EQUAL . r_value
    (24) r_value -> . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    r_value                        shift and go to state 90
    expr                           shift and go to state 91
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 52

    (19) conditional -> IF LPAREN . expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 92
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 53

    (38) expr -> LPAREN expr . RPAREN
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr
    (7) statement -> expr . SEMICOLON

    RPAREN          shift and go to state 93
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    SEMICOLON       shift and go to state 36


state 54

    (49) expr -> LPAREN statement_list . RPAREN

    RPAREN          shift and go to state 94


state 55

    (37) expr -> ID .
    (39) func_call -> ID . LPAREN arg_list RPAREN
    (25) l_value -> ID .
    (26) l_value -> ID . fields
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

  ! reduce/reduce conflict for EQUAL resolved using rule 25 (l_value -> ID .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RPAREN          reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    MULTIPLY        reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    BANG            reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    AND             reduce using rule 37 (expr -> ID .)
    OR              reduce using rule 37 (expr -> ID .)
    SEMICOLON       reduce using rule 37 (expr -> ID .)
    LPAREN          shift and go to state 60
    EQUAL           reduce using rule 25 (l_value -> ID .)
    LBRACKET        shift and go to state 61

  ! LBRACKET        [ reduce using rule 37 (expr -> ID .) ]
  ! EQUAL           [ reduce using rule 37 (expr -> ID .) ]

    fields                         shift and go to state 59

state 56

    (48) expr -> LBRACE record_list . RBRACE

    RBRACE          shift and go to state 95


state 57

    (50) record_list -> ID . COLON expr
    (51) record_list -> ID . COLON expr COMMA record_list

    COLON           shift and go to state 96


state 58

    (52) record_list -> empty .

    RBRACE          reduce using rule 52 (record_list -> empty .)


state 59

    (26) l_value -> ID fields .

    EQUAL           reduce using rule 26 (l_value -> ID fields .)


state 60

    (39) func_call -> ID LPAREN . arg_list RPAREN
    (40) arg_list -> . empty
    (41) arg_list -> . expr
    (42) arg_list -> . expr COMMA arg_list
    (3) empty -> .
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    RPAREN          reduce using rule 3 (empty -> .)
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    arg_list                       shift and go to state 97
    empty                          shift and go to state 63
    expr                           shift and go to state 64
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 61

    (29) fields -> LBRACKET . expr RBRACKET
    (30) fields -> LBRACKET . expr RBRACKET fields
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 98
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 62

    (47) expr -> LBRACKET arg_list . RBRACKET

    RBRACKET        shift and go to state 99


state 63

    (40) arg_list -> empty .

    RBRACKET        reduce using rule 40 (arg_list -> empty .)
    RPAREN          reduce using rule 40 (arg_list -> empty .)


state 64

    (41) arg_list -> expr .
    (42) arg_list -> expr . COMMA arg_list
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RBRACKET        reduce using rule 41 (arg_list -> expr .)
    RPAREN          reduce using rule 41 (arg_list -> expr .)
    COMMA           shift and go to state 100
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 65

    (28) l_value -> PLACEHOLDER fields .

    EQUAL           reduce using rule 28 (l_value -> PLACEHOLDER fields .)


state 66

    (66) macro_def -> MAC macro_def_arg_list . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 101


state 67

    (67) macro_def_arg_list -> ATOM . macro_def_arg_list_rec
    (68) macro_def_arg_list_rec -> . PLACEHOLDER macro_def_arg_list_rec
    (69) macro_def_arg_list_rec -> . ATOM macro_def_arg_list_rec
    (70) macro_def_arg_list_rec -> . empty
    (3) empty -> .

    PLACEHOLDER     shift and go to state 104
    ATOM            shift and go to state 102
    LBRACE          reduce using rule 3 (empty -> .)

    macro_def_arg_list_rec         shift and go to state 103
    empty                          shift and go to state 105

state 68

    (72) macro_arg_list -> ATOM . macro_arg_list
    (72) macro_arg_list -> . ATOM macro_arg_list
    (73) macro_arg_list -> . expr macro_arg_list
    (74) macro_arg_list -> . empty
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (3) empty -> .
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    ATOM            shift and go to state 68
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    SEMICOLON       reduce using rule 3 (empty -> .)
    NOT             shift and go to state 32

    macro_arg_list                 shift and go to state 106
    expr                           shift and go to state 70
    empty                          shift and go to state 71
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 69

    (71) macro_call -> ATOM macro_arg_list . SEMICOLON

    SEMICOLON       shift and go to state 107


state 70

    (73) macro_arg_list -> expr . macro_arg_list
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr
    (72) macro_arg_list -> . ATOM macro_arg_list
    (73) macro_arg_list -> . expr macro_arg_list
    (74) macro_arg_list -> . empty
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (3) empty -> .
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    LBRACKET        shift and go to state 109
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    ATOM            shift and go to state 68
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    SEMICOLON       reduce using rule 3 (empty -> .)
    NOT             shift and go to state 32

    expr                           shift and go to state 70
    macro_arg_list                 shift and go to state 108
    empty                          shift and go to state 71
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 71

    (74) macro_arg_list -> empty .

    SEMICOLON       reduce using rule 74 (macro_arg_list -> empty .)


state 72

    (12) loop -> WHILE LPAREN . expr RPAREN LBRACE statement_list RBRACE
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 110
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 73

    (14) fun_def -> FUN ID . LPAREN id_list RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 111


state 74

    (65) log_op -> NOT expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 65 (log_op -> NOT expr .)
    RPAREN          reduce using rule 65 (log_op -> NOT expr .)
    COMMA           reduce using rule 65 (log_op -> NOT expr .)
    RBRACKET        reduce using rule 65 (log_op -> NOT expr .)
    ATOM            reduce using rule 65 (log_op -> NOT expr .)
    STRING          reduce using rule 65 (log_op -> NOT expr .)
    NUMBER          reduce using rule 65 (log_op -> NOT expr .)
    BOOL            reduce using rule 65 (log_op -> NOT expr .)
    NULL            reduce using rule 65 (log_op -> NOT expr .)
    ID              reduce using rule 65 (log_op -> NOT expr .)
    LPAREN          reduce using rule 65 (log_op -> NOT expr .)
    LBRACE          reduce using rule 65 (log_op -> NOT expr .)
    PLACEHOLDER     reduce using rule 65 (log_op -> NOT expr .)
    NOT             reduce using rule 65 (log_op -> NOT expr .)
    RBRACE          reduce using rule 65 (log_op -> NOT expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! PLUS            [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! MINUS           [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! MULTIPLY        [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! DIVIDE          [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! EQUAL           [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! BANG            [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! GT              [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! LT              [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! AND             [ reduce using rule 65 (log_op -> NOT expr .) ]
  ! OR              [ reduce using rule 65 (log_op -> NOT expr .) ]


state 75

    (4) statement -> IMPORT STRING SEMICOLON .

    IMPORT          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    RETURN          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    IF              reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    STRING          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    NUMBER          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    BOOL            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    NULL            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    ID              reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    LBRACKET        reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    LBRACE          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    PLACEHOLDER     reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    MAC             reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    ATOM            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    FUN             reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    NOT             reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    $end            reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    RPAREN          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> IMPORT STRING SEMICOLON .)


state 76

    (53) expr -> expr LBRACKET expr . RBRACKET
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RBRACKET        shift and go to state 112
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 77

    (43) alg_op -> expr PLUS expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 43 (alg_op -> expr PLUS expr .)
    LBRACKET        reduce using rule 43 (alg_op -> expr PLUS expr .)
    PLUS            reduce using rule 43 (alg_op -> expr PLUS expr .)
    MINUS           reduce using rule 43 (alg_op -> expr PLUS expr .)
    EQUAL           reduce using rule 43 (alg_op -> expr PLUS expr .)
    BANG            reduce using rule 43 (alg_op -> expr PLUS expr .)
    GT              reduce using rule 43 (alg_op -> expr PLUS expr .)
    LT              reduce using rule 43 (alg_op -> expr PLUS expr .)
    AND             reduce using rule 43 (alg_op -> expr PLUS expr .)
    OR              reduce using rule 43 (alg_op -> expr PLUS expr .)
    RPAREN          reduce using rule 43 (alg_op -> expr PLUS expr .)
    COMMA           reduce using rule 43 (alg_op -> expr PLUS expr .)
    RBRACKET        reduce using rule 43 (alg_op -> expr PLUS expr .)
    ATOM            reduce using rule 43 (alg_op -> expr PLUS expr .)
    STRING          reduce using rule 43 (alg_op -> expr PLUS expr .)
    NUMBER          reduce using rule 43 (alg_op -> expr PLUS expr .)
    BOOL            reduce using rule 43 (alg_op -> expr PLUS expr .)
    NULL            reduce using rule 43 (alg_op -> expr PLUS expr .)
    ID              reduce using rule 43 (alg_op -> expr PLUS expr .)
    LPAREN          reduce using rule 43 (alg_op -> expr PLUS expr .)
    LBRACE          reduce using rule 43 (alg_op -> expr PLUS expr .)
    PLACEHOLDER     reduce using rule 43 (alg_op -> expr PLUS expr .)
    NOT             reduce using rule 43 (alg_op -> expr PLUS expr .)
    RBRACE          reduce using rule 43 (alg_op -> expr PLUS expr .)
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41

  ! MULTIPLY        [ reduce using rule 43 (alg_op -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 43 (alg_op -> expr PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 37 ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! BANG            [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LT              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]


state 78

    (44) alg_op -> expr MINUS expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 44 (alg_op -> expr MINUS expr .)
    LBRACKET        reduce using rule 44 (alg_op -> expr MINUS expr .)
    PLUS            reduce using rule 44 (alg_op -> expr MINUS expr .)
    MINUS           reduce using rule 44 (alg_op -> expr MINUS expr .)
    EQUAL           reduce using rule 44 (alg_op -> expr MINUS expr .)
    BANG            reduce using rule 44 (alg_op -> expr MINUS expr .)
    GT              reduce using rule 44 (alg_op -> expr MINUS expr .)
    LT              reduce using rule 44 (alg_op -> expr MINUS expr .)
    AND             reduce using rule 44 (alg_op -> expr MINUS expr .)
    OR              reduce using rule 44 (alg_op -> expr MINUS expr .)
    RPAREN          reduce using rule 44 (alg_op -> expr MINUS expr .)
    COMMA           reduce using rule 44 (alg_op -> expr MINUS expr .)
    RBRACKET        reduce using rule 44 (alg_op -> expr MINUS expr .)
    ATOM            reduce using rule 44 (alg_op -> expr MINUS expr .)
    STRING          reduce using rule 44 (alg_op -> expr MINUS expr .)
    NUMBER          reduce using rule 44 (alg_op -> expr MINUS expr .)
    BOOL            reduce using rule 44 (alg_op -> expr MINUS expr .)
    NULL            reduce using rule 44 (alg_op -> expr MINUS expr .)
    ID              reduce using rule 44 (alg_op -> expr MINUS expr .)
    LPAREN          reduce using rule 44 (alg_op -> expr MINUS expr .)
    LBRACE          reduce using rule 44 (alg_op -> expr MINUS expr .)
    PLACEHOLDER     reduce using rule 44 (alg_op -> expr MINUS expr .)
    NOT             reduce using rule 44 (alg_op -> expr MINUS expr .)
    RBRACE          reduce using rule 44 (alg_op -> expr MINUS expr .)
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41

  ! MULTIPLY        [ reduce using rule 44 (alg_op -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 44 (alg_op -> expr MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 37 ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! BANG            [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LT              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]


state 79

    (45) alg_op -> expr MULTIPLY expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    LBRACKET        reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    PLUS            reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    MINUS           reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    MULTIPLY        reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    DIVIDE          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    EQUAL           reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    BANG            reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    GT              reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    LT              reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    AND             reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    OR              reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    COMMA           reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    RBRACKET        reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    ATOM            reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    STRING          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    NUMBER          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    BOOL            reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    NULL            reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    ID              reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    LPAREN          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    LBRACE          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    PLACEHOLDER     reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    NOT             reduce using rule 45 (alg_op -> expr MULTIPLY expr .)
    RBRACE          reduce using rule 45 (alg_op -> expr MULTIPLY expr .)

  ! LBRACKET        [ shift and go to state 37 ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! MULTIPLY        [ shift and go to state 40 ]
  ! DIVIDE          [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! BANG            [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LT              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]


state 80

    (46) alg_op -> expr DIVIDE expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    PLUS            reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    MINUS           reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    MULTIPLY        reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    EQUAL           reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    BANG            reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    GT              reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    LT              reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    AND             reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    OR              reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    RPAREN          reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    COMMA           reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    ATOM            reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    STRING          reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    NUMBER          reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    BOOL            reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    NULL            reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    ID              reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    LPAREN          reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    LBRACE          reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    PLACEHOLDER     reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    NOT             reduce using rule 46 (alg_op -> expr DIVIDE expr .)
    RBRACE          reduce using rule 46 (alg_op -> expr DIVIDE expr .)

  ! LBRACKET        [ shift and go to state 37 ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! MULTIPLY        [ shift and go to state 40 ]
  ! DIVIDE          [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! BANG            [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LT              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]


state 81

    (56) comp_op -> expr EQUAL EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 113
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 82

    (57) comp_op -> expr BANG EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 114
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 83

    (58) comp_op -> expr GT expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 58 (comp_op -> expr GT expr .)
    RPAREN          reduce using rule 58 (comp_op -> expr GT expr .)
    COMMA           reduce using rule 58 (comp_op -> expr GT expr .)
    RBRACKET        reduce using rule 58 (comp_op -> expr GT expr .)
    ATOM            reduce using rule 58 (comp_op -> expr GT expr .)
    STRING          reduce using rule 58 (comp_op -> expr GT expr .)
    NUMBER          reduce using rule 58 (comp_op -> expr GT expr .)
    BOOL            reduce using rule 58 (comp_op -> expr GT expr .)
    NULL            reduce using rule 58 (comp_op -> expr GT expr .)
    ID              reduce using rule 58 (comp_op -> expr GT expr .)
    LPAREN          reduce using rule 58 (comp_op -> expr GT expr .)
    LBRACE          reduce using rule 58 (comp_op -> expr GT expr .)
    PLACEHOLDER     reduce using rule 58 (comp_op -> expr GT expr .)
    NOT             reduce using rule 58 (comp_op -> expr GT expr .)
    RBRACE          reduce using rule 58 (comp_op -> expr GT expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! EQUAL           [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! BANG            [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! GT              [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! LT              [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! AND             [ reduce using rule 58 (comp_op -> expr GT expr .) ]
  ! OR              [ reduce using rule 58 (comp_op -> expr GT expr .) ]


state 84

    (59) comp_op -> expr GT EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 115
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 85

    (60) comp_op -> expr LT expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 60 (comp_op -> expr LT expr .)
    RPAREN          reduce using rule 60 (comp_op -> expr LT expr .)
    COMMA           reduce using rule 60 (comp_op -> expr LT expr .)
    RBRACKET        reduce using rule 60 (comp_op -> expr LT expr .)
    ATOM            reduce using rule 60 (comp_op -> expr LT expr .)
    STRING          reduce using rule 60 (comp_op -> expr LT expr .)
    NUMBER          reduce using rule 60 (comp_op -> expr LT expr .)
    BOOL            reduce using rule 60 (comp_op -> expr LT expr .)
    NULL            reduce using rule 60 (comp_op -> expr LT expr .)
    ID              reduce using rule 60 (comp_op -> expr LT expr .)
    LPAREN          reduce using rule 60 (comp_op -> expr LT expr .)
    LBRACE          reduce using rule 60 (comp_op -> expr LT expr .)
    PLACEHOLDER     reduce using rule 60 (comp_op -> expr LT expr .)
    NOT             reduce using rule 60 (comp_op -> expr LT expr .)
    RBRACE          reduce using rule 60 (comp_op -> expr LT expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! EQUAL           [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! BANG            [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! GT              [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! LT              [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! AND             [ reduce using rule 60 (comp_op -> expr LT expr .) ]
  ! OR              [ reduce using rule 60 (comp_op -> expr LT expr .) ]


state 86

    (61) comp_op -> expr LT EQUAL . expr
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 116
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 87

    (63) log_op -> expr AND expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 63 (log_op -> expr AND expr .)
    RPAREN          reduce using rule 63 (log_op -> expr AND expr .)
    COMMA           reduce using rule 63 (log_op -> expr AND expr .)
    RBRACKET        reduce using rule 63 (log_op -> expr AND expr .)
    ATOM            reduce using rule 63 (log_op -> expr AND expr .)
    STRING          reduce using rule 63 (log_op -> expr AND expr .)
    NUMBER          reduce using rule 63 (log_op -> expr AND expr .)
    BOOL            reduce using rule 63 (log_op -> expr AND expr .)
    NULL            reduce using rule 63 (log_op -> expr AND expr .)
    ID              reduce using rule 63 (log_op -> expr AND expr .)
    LPAREN          reduce using rule 63 (log_op -> expr AND expr .)
    LBRACE          reduce using rule 63 (log_op -> expr AND expr .)
    PLACEHOLDER     reduce using rule 63 (log_op -> expr AND expr .)
    NOT             reduce using rule 63 (log_op -> expr AND expr .)
    RBRACE          reduce using rule 63 (log_op -> expr AND expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! MULTIPLY        [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! EQUAL           [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! BANG            [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! GT              [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! LT              [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! AND             [ reduce using rule 63 (log_op -> expr AND expr .) ]
  ! OR              [ reduce using rule 63 (log_op -> expr AND expr .) ]


state 88

    (64) log_op -> expr OR expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 64 (log_op -> expr OR expr .)
    RPAREN          reduce using rule 64 (log_op -> expr OR expr .)
    COMMA           reduce using rule 64 (log_op -> expr OR expr .)
    RBRACKET        reduce using rule 64 (log_op -> expr OR expr .)
    ATOM            reduce using rule 64 (log_op -> expr OR expr .)
    STRING          reduce using rule 64 (log_op -> expr OR expr .)
    NUMBER          reduce using rule 64 (log_op -> expr OR expr .)
    BOOL            reduce using rule 64 (log_op -> expr OR expr .)
    NULL            reduce using rule 64 (log_op -> expr OR expr .)
    ID              reduce using rule 64 (log_op -> expr OR expr .)
    LPAREN          reduce using rule 64 (log_op -> expr OR expr .)
    LBRACE          reduce using rule 64 (log_op -> expr OR expr .)
    PLACEHOLDER     reduce using rule 64 (log_op -> expr OR expr .)
    NOT             reduce using rule 64 (log_op -> expr OR expr .)
    RBRACE          reduce using rule 64 (log_op -> expr OR expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! MULTIPLY        [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! EQUAL           [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! BANG            [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! GT              [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! LT              [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! AND             [ reduce using rule 64 (log_op -> expr OR expr .) ]
  ! OR              [ reduce using rule 64 (log_op -> expr OR expr .) ]


state 89

    (15) statement -> RETURN expr SEMICOLON .

    IMPORT          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    IF              reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    NUMBER          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    BOOL            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    ID              reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    LBRACKET        reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    PLACEHOLDER     reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    MAC             reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    ATOM            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    FUN             reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    $end            reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    RPAREN          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 15 (statement -> RETURN expr SEMICOLON .)


state 90

    (10) assignment -> l_value EQUAL r_value .

    SEMICOLON       reduce using rule 10 (assignment -> l_value EQUAL r_value .)


state 91

    (24) r_value -> expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    SEMICOLON       reduce using rule 24 (r_value -> expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 92

    (19) conditional -> IF LPAREN expr . RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RPAREN          shift and go to state 117
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 93

    (38) expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    BANG            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    ATOM            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    STRING          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NUMBER          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    BOOL            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NULL            reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    PLACEHOLDER     reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    NOT             reduce using rule 38 (expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 38 (expr -> LPAREN expr RPAREN .)


state 94

    (49) expr -> LPAREN statement_list RPAREN .

    SEMICOLON       reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    LBRACKET        reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    PLUS            reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    MINUS           reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    MULTIPLY        reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    DIVIDE          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    EQUAL           reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    BANG            reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    GT              reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    LT              reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    AND             reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    OR              reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    RPAREN          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    COMMA           reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    RBRACKET        reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    ATOM            reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    STRING          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    NUMBER          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    BOOL            reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    NULL            reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    ID              reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    LPAREN          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    LBRACE          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    PLACEHOLDER     reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    NOT             reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)
    RBRACE          reduce using rule 49 (expr -> LPAREN statement_list RPAREN .)


state 95

    (48) expr -> LBRACE record_list RBRACE .

    SEMICOLON       reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    LBRACKET        reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    PLUS            reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    MINUS           reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    MULTIPLY        reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    DIVIDE          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    EQUAL           reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    BANG            reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    GT              reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    LT              reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    AND             reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    OR              reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    RPAREN          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    COMMA           reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    RBRACKET        reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    ATOM            reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    STRING          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    NUMBER          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    BOOL            reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    NULL            reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    ID              reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    LPAREN          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    LBRACE          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    PLACEHOLDER     reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    NOT             reduce using rule 48 (expr -> LBRACE record_list RBRACE .)
    RBRACE          reduce using rule 48 (expr -> LBRACE record_list RBRACE .)


state 96

    (50) record_list -> ID COLON . expr
    (51) record_list -> ID COLON . expr COMMA record_list
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 118
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 97

    (39) func_call -> ID LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 119


state 98

    (29) fields -> LBRACKET expr . RBRACKET
    (30) fields -> LBRACKET expr . RBRACKET fields
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RBRACKET        shift and go to state 120
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 99

    (47) expr -> LBRACKET arg_list RBRACKET .

    SEMICOLON       reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    LBRACKET        reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    PLUS            reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    MINUS           reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    MULTIPLY        reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    DIVIDE          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    EQUAL           reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    BANG            reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    GT              reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    LT              reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    AND             reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    OR              reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    RPAREN          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    COMMA           reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    RBRACKET        reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    ATOM            reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    STRING          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    NUMBER          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    BOOL            reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    NULL            reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    ID              reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    LPAREN          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    LBRACE          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    PLACEHOLDER     reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    NOT             reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)
    RBRACE          reduce using rule 47 (expr -> LBRACKET arg_list RBRACKET .)


state 100

    (42) arg_list -> expr COMMA . arg_list
    (40) arg_list -> . empty
    (41) arg_list -> . expr
    (42) arg_list -> . expr COMMA arg_list
    (3) empty -> .
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    RBRACKET        reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 64
    arg_list                       shift and go to state 121
    empty                          shift and go to state 63
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 101

    (66) macro_def -> MAC macro_def_arg_list LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    statement_list                 shift and go to state 122
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 102

    (69) macro_def_arg_list_rec -> ATOM . macro_def_arg_list_rec
    (68) macro_def_arg_list_rec -> . PLACEHOLDER macro_def_arg_list_rec
    (69) macro_def_arg_list_rec -> . ATOM macro_def_arg_list_rec
    (70) macro_def_arg_list_rec -> . empty
    (3) empty -> .

    PLACEHOLDER     shift and go to state 104
    ATOM            shift and go to state 102
    LBRACE          reduce using rule 3 (empty -> .)

    macro_def_arg_list_rec         shift and go to state 123
    empty                          shift and go to state 105

state 103

    (67) macro_def_arg_list -> ATOM macro_def_arg_list_rec .

    LBRACE          reduce using rule 67 (macro_def_arg_list -> ATOM macro_def_arg_list_rec .)


state 104

    (68) macro_def_arg_list_rec -> PLACEHOLDER . macro_def_arg_list_rec
    (68) macro_def_arg_list_rec -> . PLACEHOLDER macro_def_arg_list_rec
    (69) macro_def_arg_list_rec -> . ATOM macro_def_arg_list_rec
    (70) macro_def_arg_list_rec -> . empty
    (3) empty -> .

    PLACEHOLDER     shift and go to state 104
    ATOM            shift and go to state 102
    LBRACE          reduce using rule 3 (empty -> .)

    macro_def_arg_list_rec         shift and go to state 124
    empty                          shift and go to state 105

state 105

    (70) macro_def_arg_list_rec -> empty .

    LBRACE          reduce using rule 70 (macro_def_arg_list_rec -> empty .)


state 106

    (72) macro_arg_list -> ATOM macro_arg_list .

    SEMICOLON       reduce using rule 72 (macro_arg_list -> ATOM macro_arg_list .)


state 107

    (71) macro_call -> ATOM macro_arg_list SEMICOLON .

    IMPORT          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    RETURN          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    IF              reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    STRING          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    NUMBER          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    BOOL            reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    NULL            reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    ID              reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    LPAREN          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    LBRACKET        reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    LBRACE          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    PLACEHOLDER     reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    MAC             reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    ATOM            reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    WHILE           reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    FUN             reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    NOT             reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    $end            reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    RPAREN          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)
    RBRACE          reduce using rule 71 (macro_call -> ATOM macro_arg_list SEMICOLON .)


state 108

    (73) macro_arg_list -> expr macro_arg_list .

    SEMICOLON       reduce using rule 73 (macro_arg_list -> expr macro_arg_list .)


state 109

    (53) expr -> expr LBRACKET . expr RBRACKET
    (47) expr -> LBRACKET . arg_list RBRACKET
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (40) arg_list -> . empty
    (41) arg_list -> . expr
    (42) arg_list -> . expr COMMA arg_list
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr
    (3) empty -> .

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32
    RBRACKET        reduce using rule 3 (empty -> .)

    expr                           shift and go to state 125
    arg_list                       shift and go to state 62
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27
    empty                          shift and go to state 63

state 110

    (12) loop -> WHILE LPAREN expr . RPAREN LBRACE statement_list RBRACE
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RPAREN          shift and go to state 126
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 111

    (14) fun_def -> FUN ID LPAREN . id_list RPAREN LBRACE statement_list RBRACE
    (16) id_list -> . ID
    (17) id_list -> . ID COMMA id_list
    (18) id_list -> . empty
    (3) empty -> .

    ID              shift and go to state 127
    RPAREN          reduce using rule 3 (empty -> .)

    id_list                        shift and go to state 128
    empty                          shift and go to state 129

state 112

    (53) expr -> expr LBRACKET expr RBRACKET .

    SEMICOLON       reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    MULTIPLY        reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    BANG            reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    AND             reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    OR              reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    ATOM            reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    STRING          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    NUMBER          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    BOOL            reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    NULL            reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    ID              reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    PLACEHOLDER     reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    NOT             reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 53 (expr -> expr LBRACKET expr RBRACKET .)


state 113

    (56) comp_op -> expr EQUAL EQUAL expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    RPAREN          reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    COMMA           reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    RBRACKET        reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    ATOM            reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    STRING          reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    NUMBER          reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    BOOL            reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    NULL            reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    ID              reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    LPAREN          reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    LBRACE          reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    PLACEHOLDER     reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    NOT             reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    RBRACE          reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! PLUS            [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! MINUS           [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! BANG            [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! GT              [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! LT              [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! AND             [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]
  ! OR              [ reduce using rule 56 (comp_op -> expr EQUAL EQUAL expr .) ]


state 114

    (57) comp_op -> expr BANG EQUAL expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    RPAREN          reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    COMMA           reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    RBRACKET        reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    ATOM            reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    STRING          reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    NUMBER          reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    BOOL            reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    NULL            reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    ID              reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    LPAREN          reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    LBRACE          reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    PLACEHOLDER     reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    NOT             reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    RBRACE          reduce using rule 57 (comp_op -> expr BANG EQUAL expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! PLUS            [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! MINUS           [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! BANG            [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! GT              [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! LT              [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! AND             [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]
  ! OR              [ reduce using rule 57 (comp_op -> expr BANG EQUAL expr .) ]


state 115

    (59) comp_op -> expr GT EQUAL expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    RPAREN          reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    COMMA           reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    RBRACKET        reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    ATOM            reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    STRING          reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    NUMBER          reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    BOOL            reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    NULL            reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    ID              reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    LPAREN          reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    LBRACE          reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    PLACEHOLDER     reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    NOT             reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    RBRACE          reduce using rule 59 (comp_op -> expr GT EQUAL expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! PLUS            [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! MINUS           [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! BANG            [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! GT              [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! LT              [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! AND             [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]
  ! OR              [ reduce using rule 59 (comp_op -> expr GT EQUAL expr .) ]


state 116

    (61) comp_op -> expr LT EQUAL expr .
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for BANG resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    RPAREN          reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    COMMA           reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    RBRACKET        reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    ATOM            reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    STRING          reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    NUMBER          reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    BOOL            reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    NULL            reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    ID              reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    LPAREN          reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    LBRACE          reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    PLACEHOLDER     reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    NOT             reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    RBRACE          reduce using rule 61 (comp_op -> expr LT EQUAL expr .)
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! LBRACKET        [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! PLUS            [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! MINUS           [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! MULTIPLY        [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! BANG            [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! GT              [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! LT              [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! AND             [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]
  ! OR              [ reduce using rule 61 (comp_op -> expr LT EQUAL expr .) ]


state 117

    (19) conditional -> IF LPAREN expr RPAREN . LBRACE statement_list RBRACE conditional_elif conditional_else

    LBRACE          shift and go to state 130


state 118

    (50) record_list -> ID COLON expr .
    (51) record_list -> ID COLON expr . COMMA record_list
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RBRACE          reduce using rule 50 (record_list -> ID COLON expr .)
    COMMA           shift and go to state 131
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 119

    (39) func_call -> ID LPAREN arg_list RPAREN .

    SEMICOLON       reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    LBRACKET        reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    MULTIPLY        reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    EQUAL           reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    BANG            reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    GT              reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    LT              reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    AND             reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    OR              reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    ATOM            reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    STRING          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    NUMBER          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    BOOL            reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    NULL            reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    ID              reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    LPAREN          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    LBRACE          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    PLACEHOLDER     reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    NOT             reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 39 (func_call -> ID LPAREN arg_list RPAREN .)


state 120

    (29) fields -> LBRACKET expr RBRACKET .
    (30) fields -> LBRACKET expr RBRACKET . fields
    (29) fields -> . LBRACKET expr RBRACKET
    (30) fields -> . LBRACKET expr RBRACKET fields

    EQUAL           reduce using rule 29 (fields -> LBRACKET expr RBRACKET .)
    LBRACKET        shift and go to state 61

    fields                         shift and go to state 132

state 121

    (42) arg_list -> expr COMMA arg_list .

    RBRACKET        reduce using rule 42 (arg_list -> expr COMMA arg_list .)
    RPAREN          reduce using rule 42 (arg_list -> expr COMMA arg_list .)


state 122

    (66) macro_def -> MAC macro_def_arg_list LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 133


state 123

    (69) macro_def_arg_list_rec -> ATOM macro_def_arg_list_rec .

    LBRACE          reduce using rule 69 (macro_def_arg_list_rec -> ATOM macro_def_arg_list_rec .)


state 124

    (68) macro_def_arg_list_rec -> PLACEHOLDER macro_def_arg_list_rec .

    LBRACE          reduce using rule 68 (macro_def_arg_list_rec -> PLACEHOLDER macro_def_arg_list_rec .)


state 125

    (53) expr -> expr LBRACKET expr . RBRACKET
    (53) expr -> expr . LBRACKET expr RBRACKET
    (41) arg_list -> expr .
    (42) arg_list -> expr . COMMA arg_list
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 112
    LBRACKET        shift and go to state 37
    COMMA           shift and go to state 100
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! RBRACKET        [ reduce using rule 41 (arg_list -> expr .) ]


state 126

    (12) loop -> WHILE LPAREN expr RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 134


state 127

    (16) id_list -> ID .
    (17) id_list -> ID . COMMA id_list

    RPAREN          reduce using rule 16 (id_list -> ID .)
    COMMA           shift and go to state 135


state 128

    (14) fun_def -> FUN ID LPAREN id_list . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 136


state 129

    (18) id_list -> empty .

    RPAREN          reduce using rule 18 (id_list -> empty .)


state 130

    (19) conditional -> IF LPAREN expr RPAREN LBRACE . statement_list RBRACE conditional_elif conditional_else
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    expr                           shift and go to state 8
    statement_list                 shift and go to state 137
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 131

    (51) record_list -> ID COLON expr COMMA . record_list
    (50) record_list -> . ID COLON expr
    (51) record_list -> . ID COLON expr COMMA record_list
    (52) record_list -> . empty
    (3) empty -> .

    ID              shift and go to state 57
    RBRACE          reduce using rule 3 (empty -> .)

    record_list                    shift and go to state 138
    empty                          shift and go to state 58

state 132

    (30) fields -> LBRACKET expr RBRACKET fields .

    EQUAL           reduce using rule 30 (fields -> LBRACKET expr RBRACKET fields .)


state 133

    (66) macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    IF              reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    STRING          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    NULL            reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    ID              reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    MAC             reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    FUN             reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    NOT             reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    $end            reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 66 (macro_def -> MAC macro_def_arg_list LBRACE statement_list RBRACE .)


state 134

    (12) loop -> WHILE LPAREN expr RPAREN LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    expr                           shift and go to state 8
    statement_list                 shift and go to state 139
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 135

    (17) id_list -> ID COMMA . id_list
    (16) id_list -> . ID
    (17) id_list -> . ID COMMA id_list
    (18) id_list -> . empty
    (3) empty -> .

    ID              shift and go to state 127
    RPAREN          reduce using rule 3 (empty -> .)

    id_list                        shift and go to state 140
    empty                          shift and go to state 129

state 136

    (14) fun_def -> FUN ID LPAREN id_list RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 141


state 137

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list . RBRACE conditional_elif conditional_else

    RBRACE          shift and go to state 142


state 138

    (51) record_list -> ID COLON expr COMMA record_list .

    RBRACE          reduce using rule 51 (record_list -> ID COLON expr COMMA record_list .)


state 139

    (12) loop -> WHILE LPAREN expr RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 143


state 140

    (17) id_list -> ID COMMA id_list .

    RPAREN          reduce using rule 17 (id_list -> ID COMMA id_list .)


state 141

    (14) fun_def -> FUN ID LPAREN id_list RPAREN LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    statement_list                 shift and go to state 144
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 142

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE . conditional_elif conditional_else
    (20) conditional_elif -> . ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif
    (21) conditional_elif -> . empty
    (3) empty -> .

    ELIF            shift and go to state 146
    ELSE            reduce using rule 3 (empty -> .)
    IMPORT          reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    NUMBER          reduce using rule 3 (empty -> .)
    BOOL            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    LBRACKET        reduce using rule 3 (empty -> .)
    LBRACE          reduce using rule 3 (empty -> .)
    PLACEHOLDER     reduce using rule 3 (empty -> .)
    MAC             reduce using rule 3 (empty -> .)
    ATOM            reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FUN             reduce using rule 3 (empty -> .)
    NOT             reduce using rule 3 (empty -> .)
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)

    conditional_elif               shift and go to state 145
    empty                          shift and go to state 147

state 143

    (12) loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    NULL            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    ID              reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    MAC             reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    FUN             reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    NOT             reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 12 (loop -> WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE .)


state 144

    (14) fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 148


state 145

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif . conditional_else
    (22) conditional_else -> . ELSE LBRACE statement_list RBRACE
    (23) conditional_else -> . empty
    (3) empty -> .

    ELSE            shift and go to state 150
    IMPORT          reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    NUMBER          reduce using rule 3 (empty -> .)
    BOOL            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    LBRACKET        reduce using rule 3 (empty -> .)
    LBRACE          reduce using rule 3 (empty -> .)
    PLACEHOLDER     reduce using rule 3 (empty -> .)
    MAC             reduce using rule 3 (empty -> .)
    ATOM            reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FUN             reduce using rule 3 (empty -> .)
    NOT             reduce using rule 3 (empty -> .)
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)

    conditional_else               shift and go to state 149
    empty                          shift and go to state 151

state 146

    (20) conditional_elif -> ELIF . LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif

    LPAREN          shift and go to state 152


state 147

    (21) conditional_elif -> empty .

    ELSE            reduce using rule 21 (conditional_elif -> empty .)
    IMPORT          reduce using rule 21 (conditional_elif -> empty .)
    RETURN          reduce using rule 21 (conditional_elif -> empty .)
    IF              reduce using rule 21 (conditional_elif -> empty .)
    STRING          reduce using rule 21 (conditional_elif -> empty .)
    NUMBER          reduce using rule 21 (conditional_elif -> empty .)
    BOOL            reduce using rule 21 (conditional_elif -> empty .)
    NULL            reduce using rule 21 (conditional_elif -> empty .)
    ID              reduce using rule 21 (conditional_elif -> empty .)
    LPAREN          reduce using rule 21 (conditional_elif -> empty .)
    LBRACKET        reduce using rule 21 (conditional_elif -> empty .)
    LBRACE          reduce using rule 21 (conditional_elif -> empty .)
    PLACEHOLDER     reduce using rule 21 (conditional_elif -> empty .)
    MAC             reduce using rule 21 (conditional_elif -> empty .)
    ATOM            reduce using rule 21 (conditional_elif -> empty .)
    WHILE           reduce using rule 21 (conditional_elif -> empty .)
    FUN             reduce using rule 21 (conditional_elif -> empty .)
    NOT             reduce using rule 21 (conditional_elif -> empty .)
    $end            reduce using rule 21 (conditional_elif -> empty .)
    RPAREN          reduce using rule 21 (conditional_elif -> empty .)
    RBRACE          reduce using rule 21 (conditional_elif -> empty .)


state 148

    (14) fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NULL            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    ID              reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    MAC             reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    FUN             reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    NOT             reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 14 (fun_def -> FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE .)


state 149

    (19) conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .

    IMPORT          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    RETURN          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    IF              reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    STRING          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    NUMBER          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    BOOL            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    NULL            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    ID              reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    LPAREN          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    LBRACKET        reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    LBRACE          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    PLACEHOLDER     reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    MAC             reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    ATOM            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    WHILE           reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    FUN             reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    NOT             reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    $end            reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    RPAREN          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)
    RBRACE          reduce using rule 19 (conditional -> IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else .)


state 150

    (22) conditional_else -> ELSE . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 153


state 151

    (23) conditional_else -> empty .

    IMPORT          reduce using rule 23 (conditional_else -> empty .)
    RETURN          reduce using rule 23 (conditional_else -> empty .)
    IF              reduce using rule 23 (conditional_else -> empty .)
    STRING          reduce using rule 23 (conditional_else -> empty .)
    NUMBER          reduce using rule 23 (conditional_else -> empty .)
    BOOL            reduce using rule 23 (conditional_else -> empty .)
    NULL            reduce using rule 23 (conditional_else -> empty .)
    ID              reduce using rule 23 (conditional_else -> empty .)
    LPAREN          reduce using rule 23 (conditional_else -> empty .)
    LBRACKET        reduce using rule 23 (conditional_else -> empty .)
    LBRACE          reduce using rule 23 (conditional_else -> empty .)
    PLACEHOLDER     reduce using rule 23 (conditional_else -> empty .)
    MAC             reduce using rule 23 (conditional_else -> empty .)
    ATOM            reduce using rule 23 (conditional_else -> empty .)
    WHILE           reduce using rule 23 (conditional_else -> empty .)
    FUN             reduce using rule 23 (conditional_else -> empty .)
    NOT             reduce using rule 23 (conditional_else -> empty .)
    $end            reduce using rule 23 (conditional_else -> empty .)
    RPAREN          reduce using rule 23 (conditional_else -> empty .)
    RBRACE          reduce using rule 23 (conditional_else -> empty .)


state 152

    (20) conditional_elif -> ELIF LPAREN . expr RPAREN LBRACE statement_list RBRACE conditional_elif
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 49
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 50
    NOT             shift and go to state 32

    expr                           shift and go to state 154
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 153

    (22) conditional_else -> ELSE LBRACE . statement_list RBRACE
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    statement_list                 shift and go to state 155
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    expr                           shift and go to state 8
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 154

    (20) conditional_elif -> ELIF LPAREN expr . RPAREN LBRACE statement_list RBRACE conditional_elif
    (53) expr -> expr . LBRACKET expr RBRACKET
    (43) alg_op -> expr . PLUS expr
    (44) alg_op -> expr . MINUS expr
    (45) alg_op -> expr . MULTIPLY expr
    (46) alg_op -> expr . DIVIDE expr
    (56) comp_op -> expr . EQUAL EQUAL expr
    (57) comp_op -> expr . BANG EQUAL expr
    (58) comp_op -> expr . GT expr
    (59) comp_op -> expr . GT EQUAL expr
    (60) comp_op -> expr . LT expr
    (61) comp_op -> expr . LT EQUAL expr
    (63) log_op -> expr . AND expr
    (64) log_op -> expr . OR expr

    RPAREN          shift and go to state 156
    LBRACKET        shift and go to state 37
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    MULTIPLY        shift and go to state 40
    DIVIDE          shift and go to state 41
    EQUAL           shift and go to state 42
    BANG            shift and go to state 43
    GT              shift and go to state 44
    LT              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 155

    (22) conditional_else -> ELSE LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 157


state 156

    (20) conditional_elif -> ELIF LPAREN expr RPAREN . LBRACE statement_list RBRACE conditional_elif

    LBRACE          shift and go to state 158


state 157

    (22) conditional_else -> ELSE LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    STRING          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    NULL            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    ID              reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    PLACEHOLDER     reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    MAC             reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    ATOM            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    FUN             reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    NOT             reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    $end            reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 22 (conditional_else -> ELSE LBRACE statement_list RBRACE .)


state 158

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE . statement_list RBRACE conditional_elif
    (1) statement_list -> . statement statement_list
    (2) statement_list -> . empty
    (4) statement -> . IMPORT STRING SEMICOLON
    (5) statement -> . assignment SEMICOLON
    (6) statement -> . conditional
    (7) statement -> . expr SEMICOLON
    (8) statement -> . macro_def
    (9) statement -> . macro_call
    (11) statement -> . loop
    (13) statement -> . fun_def
    (15) statement -> . RETURN expr SEMICOLON
    (3) empty -> .
    (10) assignment -> . l_value EQUAL r_value
    (19) conditional -> . IF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif conditional_else
    (31) expr -> . alg_op
    (32) expr -> . STRING
    (33) expr -> . NUMBER
    (34) expr -> . BOOL
    (35) expr -> . NULL
    (36) expr -> . func_call
    (37) expr -> . ID
    (38) expr -> . LPAREN expr RPAREN
    (47) expr -> . LBRACKET arg_list RBRACKET
    (48) expr -> . LBRACE record_list RBRACE
    (49) expr -> . LPAREN statement_list RPAREN
    (53) expr -> . expr LBRACKET expr RBRACKET
    (54) expr -> . comp_op
    (55) expr -> . PLACEHOLDER
    (62) expr -> . log_op
    (66) macro_def -> . MAC macro_def_arg_list LBRACE statement_list RBRACE
    (71) macro_call -> . ATOM macro_arg_list SEMICOLON
    (12) loop -> . WHILE LPAREN expr RPAREN LBRACE statement_list RBRACE
    (14) fun_def -> . FUN ID LPAREN id_list RPAREN LBRACE statement_list RBRACE
    (25) l_value -> . ID
    (26) l_value -> . ID fields
    (27) l_value -> . PLACEHOLDER
    (28) l_value -> . PLACEHOLDER fields
    (43) alg_op -> . expr PLUS expr
    (44) alg_op -> . expr MINUS expr
    (45) alg_op -> . expr MULTIPLY expr
    (46) alg_op -> . expr DIVIDE expr
    (39) func_call -> . ID LPAREN arg_list RPAREN
    (56) comp_op -> . expr EQUAL EQUAL expr
    (57) comp_op -> . expr BANG EQUAL expr
    (58) comp_op -> . expr GT expr
    (59) comp_op -> . expr GT EQUAL expr
    (60) comp_op -> . expr LT expr
    (61) comp_op -> . expr LT EQUAL expr
    (63) log_op -> . expr AND expr
    (64) log_op -> . expr OR expr
    (65) log_op -> . NOT expr

    IMPORT          shift and go to state 4
    RETURN          shift and go to state 13
    RBRACE          reduce using rule 3 (empty -> .)
    IF              shift and go to state 15
    STRING          shift and go to state 5
    NUMBER          shift and go to state 19
    BOOL            shift and go to state 20
    NULL            shift and go to state 21
    ID              shift and go to state 23
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 24
    LBRACE          shift and go to state 17
    PLACEHOLDER     shift and go to state 26
    MAC             shift and go to state 28
    ATOM            shift and go to state 29
    WHILE           shift and go to state 30
    FUN             shift and go to state 31
    NOT             shift and go to state 32

    expr                           shift and go to state 8
    statement_list                 shift and go to state 159
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    assignment                     shift and go to state 6
    conditional                    shift and go to state 7
    macro_def                      shift and go to state 9
    macro_call                     shift and go to state 10
    loop                           shift and go to state 11
    fun_def                        shift and go to state 12
    l_value                        shift and go to state 14
    alg_op                         shift and go to state 18
    func_call                      shift and go to state 22
    comp_op                        shift and go to state 25
    log_op                         shift and go to state 27

state 159

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list . RBRACE conditional_elif

    RBRACE          shift and go to state 160


state 160

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE . conditional_elif
    (20) conditional_elif -> . ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif
    (21) conditional_elif -> . empty
    (3) empty -> .

    ELIF            shift and go to state 146
    ELSE            reduce using rule 3 (empty -> .)
    IMPORT          reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    NUMBER          reduce using rule 3 (empty -> .)
    BOOL            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    LBRACKET        reduce using rule 3 (empty -> .)
    LBRACE          reduce using rule 3 (empty -> .)
    PLACEHOLDER     reduce using rule 3 (empty -> .)
    MAC             reduce using rule 3 (empty -> .)
    ATOM            reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FUN             reduce using rule 3 (empty -> .)
    NOT             reduce using rule 3 (empty -> .)
    $end            reduce using rule 3 (empty -> .)
    RPAREN          reduce using rule 3 (empty -> .)
    RBRACE          reduce using rule 3 (empty -> .)

    conditional_elif               shift and go to state 161
    empty                          shift and go to state 147

state 161

    (20) conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .

    ELSE            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    IMPORT          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    RETURN          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    IF              reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    STRING          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    NUMBER          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    BOOL            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    NULL            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    ID              reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    LPAREN          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    LBRACKET        reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    LBRACE          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    PLACEHOLDER     reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    MAC             reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    ATOM            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    WHILE           reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    FUN             reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    NOT             reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    $end            reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    RPAREN          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)
    RBRACE          reduce using rule 20 (conditional_elif -> ELIF LPAREN expr RPAREN LBRACE statement_list RBRACE conditional_elif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 23 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 26 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 49 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 55 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 74 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 74 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 74 resolved as shift
WARNING: shift/reduce conflict for BANG in state 74 resolved as shift
WARNING: shift/reduce conflict for GT in state 74 resolved as shift
WARNING: shift/reduce conflict for LT in state 74 resolved as shift
WARNING: shift/reduce conflict for AND in state 74 resolved as shift
WARNING: shift/reduce conflict for OR in state 74 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 83 resolved as shift
WARNING: shift/reduce conflict for BANG in state 83 resolved as shift
WARNING: shift/reduce conflict for GT in state 83 resolved as shift
WARNING: shift/reduce conflict for LT in state 83 resolved as shift
WARNING: shift/reduce conflict for AND in state 83 resolved as shift
WARNING: shift/reduce conflict for OR in state 83 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 85 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 85 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 85 resolved as shift
WARNING: shift/reduce conflict for BANG in state 85 resolved as shift
WARNING: shift/reduce conflict for GT in state 85 resolved as shift
WARNING: shift/reduce conflict for LT in state 85 resolved as shift
WARNING: shift/reduce conflict for AND in state 85 resolved as shift
WARNING: shift/reduce conflict for OR in state 85 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 87 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 87 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 87 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 87 resolved as shift
WARNING: shift/reduce conflict for BANG in state 87 resolved as shift
WARNING: shift/reduce conflict for GT in state 87 resolved as shift
WARNING: shift/reduce conflict for LT in state 87 resolved as shift
WARNING: shift/reduce conflict for AND in state 87 resolved as shift
WARNING: shift/reduce conflict for OR in state 87 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 88 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 88 resolved as shift
WARNING: shift/reduce conflict for BANG in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for AND in state 88 resolved as shift
WARNING: shift/reduce conflict for OR in state 88 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for BANG in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for BANG in state 114 resolved as shift
WARNING: shift/reduce conflict for GT in state 114 resolved as shift
WARNING: shift/reduce conflict for LT in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for BANG in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for BANG in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 125 resolved as shift
WARNING: reduce/reduce conflict in state 23 resolved using rule (l_value -> ID)
WARNING: rejected rule (expr -> ID) in state 23
WARNING: reduce/reduce conflict in state 26 resolved using rule (l_value -> PLACEHOLDER)
WARNING: rejected rule (expr -> PLACEHOLDER) in state 26
WARNING: reduce/reduce conflict in state 55 resolved using rule (l_value -> ID)
WARNING: rejected rule (expr -> ID) in state 55
